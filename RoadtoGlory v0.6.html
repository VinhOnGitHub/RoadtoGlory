<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web học tiếng Trung của Vinh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: {
                            DEFAULT: '#4f46e5',
                            100: '#e0e7ff',
                            700: '#4338ca',
                            800: '#3730a3',
                            900: '#312e81',
                        },
                    },
                },
            },
        }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="icon" href="./assets/img/thumbnail.png" type="image/x-icon" />
    <style>
        /* Import Inter font from Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }

        /* Keyframe animation for fade-in effect */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }

        /* Keyframe animation for shake effect (for wrong answer) */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        .animate-shake {
            animation: shake 0.5s ease-in-out;
        }

        /* Overlay for processing state on forms */
        .form-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: inherit;
        }

        /* Modal specific styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 400px;
            animation: fadeIn 0.3s ease-out;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel" data-presets="react" data-plugins="proposal-optional-chaining">
        const { useState, useEffect, useRef } = React;

        // Keys for storing data in localStorage and IndexedDB
        const LOCAL_STORAGE_KEY = 'chineseVocabLessons';
        const COURSE_STORAGE_KEY = 'chineseVocabCourses';
        const DB_NAME = 'ChineseVocabDB';
        const STORE_NAME = 'audioFiles';
        const DB_VERSION = 1;

        // Correct streak required to "graduate" a difficult word
        const CORRECT_STREAK_TO_GRADUATE = 10;

        // --- IndexedDB Helper Functions ---
        const openDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };

                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };

                request.onerror = (event) => {
                    reject('Error opening IndexedDB: ' + event.target.errorCode);
                };
            });
        };

        const storeAudioFile = async (id, fileBlob) => {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put({ id: id, data: fileBlob });
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject('Error storing audio: ' + event.target.errorCode);
            });
        };

        const getAudioFile = async (id) => {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(id);
                request.onsuccess = (event) => {
                    const result = event.target.result;
                    resolve(result ? result.data : null);
                };
                request.onerror = (event) => reject('Error getting audio: ' + event.target.errorCode);
            });
        };

        const deleteAudioFile = async (id) => {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject('Error deleting audio: ' + event.target.errorCode);
            });
        };

        const getAllAudioFiles = async () => {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                request.onerror = (event) => reject('Error getting all audio: ' + event.target.errorCode);
            });
        };

        const clearAllAudioFiles = async () => {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject('Error clearing audio files: ' + event.target.errorCode);
            });
        };

        // --- Utility components/functions ---
        const LoadingSpinner = () => (
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-primary"></div>
        );

        const FullPageLoadingOverlay = ({ message = "Đang tải...", showSpinner = true }) => (
            <div className="fixed inset-0 bg-white dark:bg-gray-900 bg-opacity-80 dark:bg-opacity-80 flex flex-col items-center justify-center z-50">
                {showSpinner && <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mb-4"></div>}
                <p className="text-lg text-gray-700 dark:text-gray-200">{message}</p>
            </div>
        );

        const MessageBox = ({ message, type, onClose }) => (
            <div className={`p-4 rounded-lg shadow-md flex items-center justify-between mt-4 ${
                type === 'success'
                    ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200'
                    : type === 'error'
                    ? 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200'
                    : 'bg-primary-100 text-primary dark:bg-primary-800 dark:text-primary-100'
            }`}>
                <p>{message}</p>
                {onClose && (
                    <button onClick={onClose} className="text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 focus:outline-none">
                        <i className="fas fa-times"></i>
                    </button>
                )}
            </div>
        );

        // Safely parse date from string or existing Date object
        const safeParseDate = (dateValue) => {
            if (dateValue instanceof Date && !isNaN(dateValue)) {
                return dateValue;
            }
            if (typeof dateValue === 'string') {
                const date = new Date(dateValue);
                if (!isNaN(date)) {
                    return date;
                }
            }
            return null;
        };

        // --- Global Audio Control ---
        let currentAudioInstance = null;
        let currentUtteranceInstance = null;

        const stopSpeaking = () => {
            if (currentAudioInstance) {
                currentAudioInstance.pause();
                if (currentAudioInstance.src) {
                    URL.revokeObjectURL(currentAudioInstance.src);
                }
                currentAudioInstance = null;
            }
            if ('speechSynthesis' in window && speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            currentUtteranceInstance = null;
            console.log("Stopped all speaking/audio.");
        };

        const speakText = async (textToSpeak, audioIdToPlay = null, playbackRate = 1.0, onEndCallback = null) => {
            if (!textToSpeak) return;

            stopSpeaking();

            if (audioIdToPlay) {
                try {
                    const audioBlob = await getAudioFile(audioIdToPlay);
                    if (audioBlob) {
                        currentAudioInstance = new Audio(URL.createObjectURL(audioBlob));
                        currentAudioInstance.onended = () => {
                            URL.revokeObjectURL(currentAudioInstance.src);
                            currentAudioInstance = null;
                            if (onEndCallback) onEndCallback();
                        };
                        currentAudioInstance.onerror = (e) => {
                            console.error("Error playing audio from Blob, falling back to TTS:", e);
                            URL.revokeObjectURL(currentAudioInstance.src);
                            currentAudioInstance = null;
                            if ('speechSynthesis' in window) {
                                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                                utterance.lang = 'zh-CN';
                                utterance.rate = playbackRate;
                                utterance.onend = () => {
                                    currentUtteranceInstance = null;
                                    if (onEndCallback) onEndCallback();
                                };
                                currentUtteranceInstance = utterance;
                                speechSynthesis.speak(utterance);
                            } else {
                                console.warn("Trình duyệt của bạn không hỗ trợ tính năng đọc văn bản.");
                                if (onEndCallback) onEndCallback();
                            }
                        };
                        currentAudioInstance.play().catch(e => {
                            console.error("Play promise rejected for audio, falling back to TTS:", e);
                            if ('speechSynthesis' in window) {
                                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                                utterance.lang = 'zh-CN';
                                utterance.rate = playbackRate;
                                utterance.onend = () => {
                                    currentUtteranceInstance = null;
                                    if (onEndCallback) onEndCallback();
                                };
                                currentUtteranceInstance = utterance;
                                speechSynthesis.speak(utterance);
                            } else {
                                console.warn("Trình duyệt của bạn không hỗ trợ tính năng đọc văn bản.");
                                if (onEndCallback) onEndCallback();
                            }
                        });
                        console.log("Playing audio from IndexedDB:", audioIdToPlay);
                        return;
                    }
                } catch (e) {
                    console.error("Error retrieving audio blob, falling back to TTS:", e);
                }
            }

            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                utterance.lang = 'zh-CN';
                utterance.rate = playbackRate;
                utterance.onend = () => {
                    currentUtteranceInstance = null;
                    if (onEndCallback) onEndCallback();
                };
                currentUtteranceInstance = utterance;
                speechSynthesis.speak(utterance);
                console.log("Using browser TTS for text:", textToSpeak);
            } else {
                console.warn("Trình duyệt của bạn không hỗ trợ tính năng đọc văn bản.");
                if (onEndCallback) onEndCallback();
            }
        };


        // --- Main App Component ---
        const App = () => {
            const [courses, setCourses] = useState([]);
            const [lessons, setLessons] = useState([]);
            const [vocabularies, setVocabularies] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [message, setMessage] = useState(null);
            const [view, setView] = useState('lessonList');
            const [selectedLesson, setSelectedLesson] = useState(null);
            const [allVocabularies, setAllVocabularies] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);

            // Form states for creating/editing a lesson
            const [lessonName, setLessonName] = useState('');
            const [lessonCourseId, setLessonCourseId] = useState('');
            const [editingLesson, setEditingLesson] = useState(null);

            // Form states for creating/editing a course
            const [courseName, setCourseName] = useState('');
            const [editingCourse, setEditingCourse] = useState(null);

            // Form states for creating/editing a vocabulary
            const [editingVocab, setEditingVocab] = useState(null);
            const [hanTu, setHanTu] = useState('');
            const [pinyin, setPinyin] = useState('');
            const [meaning, setMeaning] = useState('');
            const [hanVietMeaning, setHanVietMeaning] = useState('');
            const [notes, setNotes] = useState('');
            const [audioFileBlob, setAudioFileBlob] = useState(null);
            const [currentAudioFileId, setCurrentAudioFileId] = useState(null);
            const [examples, setExamples] = useState(Array(6).fill({ chinese: '', vietnamese: '', audioFileBlob: null, audioFileId: null }));


            // Review game states
            const [showPinyin, setShowPinyin] = useState(false);
            const [question, setQuestion] = useState(null);
            const [options, setOptions] = useState([]);
            const [correctAnswerIndex, setCorrectAnswerIndex] = useState(-1);
            const [selectedOption, setSelectedOption] = useState(null);
            const [isCorrect, setIsCorrect] = useState(null);
            const [score, setScore] = useState(0);
            const [currentQuestionNumber, setCurrentQuestionNumber] = useState(0);
            const [totalQuestions, setTotalQuestions] = useState(0);
            const [shaking, setShaking] = useState(false);
            const [reviewVocabList, setReviewVocabList] = useState([]);
            const [reviewMode, setReviewMode] = useState('');
            const [questionType, setQuestionType] = useState('');
            const [pinyinInput, setPinyinInput] = useState('');
            const [hanTuInput, setHanTuInput] = useState('');
            const [showReviewLimitModal, setShowReviewLimitModal] = useState({ isVisible: false, isDifficult: false });
            const [tempReviewLimit, setTempReviewLimit] = useState('');
            const [reviewSourceVocabs, setReviewSourceVocabs] = useState([]);
            
            // For rearrangeExample question type
            const [scrambledWords, setScrambledWords] = useState([]);
            const [selectedWords, setSelectedWords] = useState([]);
            const [rearrangeIsAnswered, setRearrangeIsAnswered] = useState(false);

            // New states for study goals and daily check-in
            const [targetDate, setTargetDate] = useState('');
            const [daysRemaining, setDaysRemaining] = useState(null);
            const [checkInStreak, setCheckInStreak] = useState(0);
            const [lastCheckInDate, setLastCheckInDate] = useState(null);

            // NEW: Passage Study States
            const [editingPassage, setEditingPassage] = useState(null);
            const [passageTitle, setPassageTitle] = useState('');
            const [passageSentences, setPassageSentences] = useState([{ chinese: '', pinyin: '', vietnamese: '', audioFileBlob: null, audioFileId: null, speaker: '' }]);
            const [selectedPassage, setSelectedPassage] = useState(null);
            const [passageMode, setPassageMode] = useState('reading');
            const [showPassagePinyin, setShowPassagePinyin] = useState(false);
            const [showPassageMeaning, setShowPassageMeaning] = useState(true);
            const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0);
            const [sentenceInput, setSentenceInput] = useState('');
            const [fillInBlanksWords, setFillInBlanksWords] = useState([]);
            const [dictationCorrectAnswer, setDictationCorrectAnswer] = useState('');
            const [popupWord, setPopupWord] = useState(null);
            const popupRef = useRef(null);

            // Passage playback rate state
            const [passagePlaybackRate, setPassagePlaybackRate] = useState(1); 

            // Ref for controlling full passage playback
            const isPlayingAllPassage = useRef(false);
            const currentPassageAudioIndex = useRef(0);


            // Load data from localStorage on initial render
            useEffect(() => {
                console.log("Attempting to load data from localStorage...");
                try {
                    const storedLessons = localStorage.getItem(LOCAL_STORAGE_KEY);
                    const storedCourses = localStorage.getItem(COURSE_STORAGE_KEY);
                    let loadedCourses = storedCourses ? JSON.parse(storedCourses) : [];
                    let hydratedLessons = [];
                    if (storedLessons) {
                        const parsedLessons = JSON.parse(storedLessons);
                        console.log("Parsed lessons from localStorage:", parsedLessons);
                        hydratedLessons = parsedLessons.map(lesson => {
                            const createdAtDate = safeParseDate(lesson.createdAt);
                            const updatedAtDate = safeParseDate(lesson.updatedAt);

                            return {
                                ...lesson,
                                createdAt: createdAtDate || new Date(),
                                ...(updatedAtDate && { updatedAt: updatedAtDate }),
                                vocabularies: (lesson.vocabularies || []).map(vocab => {
                                    const vocabCreatedAtDate = safeParseDate(vocab.createdAt);
                                    const vocabUpdatedAtDate = safeParseDate(vocab.updatedAt);
                                    return {
                                        ...vocab,
                                        createdAt: vocabCreatedAtDate || new Date(),
                                        ...(vocabUpdatedAtDate && { updatedAt: vocabUpdatedAtDate }),
                                        wrongAttempts: vocab.wrongAttempts || 0,
                                        correctStreak: vocab.correctStreak || 0,
                                        hanVietMeaning: vocab.hanVietMeaning || '' // Hydrate new field
                                    };
                                }),
                                passages: (lesson.passages || []).map(passage => {
                                    return {
                                        ...passage,
                                        sentences: (passage.sentences || []).map(sentence => ({
                                            ...sentence,
                                            speaker: sentence.speaker || '',
                                        }))
                                    };
                                })
                            };
                        });
                    } else {
                        console.log("No lessons found in localStorage.");
                    }

                    if (loadedCourses.length === 0) {
                        const defaultCourse = { id: `course-${Date.now()}`, name: 'Khoá học mặc định', expanded: true };
                        loadedCourses = [defaultCourse];
                    }

                    hydratedLessons = hydratedLessons.map(lesson => ({ ...lesson, courseId: lesson.courseId || loadedCourses[0].id }));

                    setCourses(loadedCourses);
                    setLessons(hydratedLessons);
                    if (hydratedLessons.length > 0) {
                        fetchAllVocabulariesFromCurrentLessons(hydratedLessons);
                    }

                    const storedTargetDate = localStorage.getItem('chineseTargetDate');
                    if (storedTargetDate) {
                        setTargetDate(storedTargetDate);
                        calculateDaysRemaining(storedTargetDate);
                    }
                    const storedCheckInStreak = localStorage.getItem('chineseCheckInStreak');
                    if (storedCheckInStreak) {
                        setCheckInStreak(parseInt(storedCheckInStreak, 10));
                    }
                    const storedLastCheckInDate = localStorage.getItem('chineseLastCheckInDate');
                    if (storedLastCheckInDate) {
                        setLastCheckInDate(new Date(storedLastCheckInDate));
                    }

                } catch (e) {
                    console.error("Failed to load data from localStorage:", e);
                    setError("Lỗi khi tải dữ liệu từ bộ nhớ cục bộ. Dữ liệu có thể bị hỏng. Vui lòng thử xóa dữ liệu trình duyệt và nhập lại backup nếu có.");
                } finally {
                    setLoading(false);
                    console.log("Initial loading complete.");
                }
            }, []);

            useEffect(() => {
                if (!loading) {
                    console.log("Lessons state changed, attempting to save to localStorage...");
                    try {
                        const serializableLessons = lessons.map(lesson => ({
                            ...lesson,
                            courseId: lesson.courseId,
                            createdAt: (lesson.createdAt instanceof Date) ? lesson.createdAt.toISOString() : new Date().toISOString(),
                            ...(lesson.updatedAt instanceof Date && { updatedAt: lesson.updatedAt.toISOString() }),
                            vocabularies: (lesson.vocabularies || []).map(vocab => ({
                                ...vocab,
                                createdAt: (vocab.createdAt instanceof Date) ? vocab.createdAt.toISOString() : new Date().toISOString(),
                                ...(vocab.updatedAt instanceof Date && { updatedAt: vocab.updatedAt.toISOString() }),
                                audioFile: vocab.audioFile,
                                examples: (vocab.examples || []).map(ex => ({
                                    ...ex,
                                    audioFile: ex.audioFile
                                })),
                                wrongAttempts: vocab.wrongAttempts || 0,
                                correctStreak: vocab.correctStreak || 0,
                                hanVietMeaning: vocab.hanVietMeaning || '' // Save new field
                            })),
                            passages: (lesson.passages || []).map(passage => ({
                                ...passage,
                                sentences: (passage.sentences || []).map(sentence => ({
                                    ...sentence,
                                    audioFile: sentence.audioFile,
                                    speaker: sentence.speaker || '',
                                }))
                            }))
                        }));
                        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(serializableLessons));
                        console.log("Lessons successfully saved to localStorage.");
                        fetchAllVocabulariesFromCurrentLessons(lessons);
                    } catch (e) {
                        console.error("Failed to save data to localStorage:", e);
                        setError("Lỗi khi lưu dữ liệu vào bộ nhớ cục bộ.");
                    }
                }
            }, [lessons, loading]);

            useEffect(() => {
                if (!loading) {
                    localStorage.setItem(COURSE_STORAGE_KEY, JSON.stringify(courses));
                }
            }, [courses, loading]);

            useEffect(() => {
                if (selectedLesson) {
                    const currentLesson = lessons.find(l => l.id === selectedLesson.id);
                    if (currentLesson) {
                        setVocabularies(currentLesson.vocabularies || []);
                        console.log("Vocabularies for selected lesson updated:", currentLesson.vocabularies);
                    } else {
                        setVocabularies([]);
                        console.log("Selected lesson not found, vocabularies cleared.");
                    }
                } else {
                    setVocabularies([]);
                    console.log("No lesson selected, vocabularies cleared.");
                }
            }, [selectedLesson, lessons]);

            const fetchAllVocabulariesFromCurrentLessons = (currentLessons) => {
                let allVocab = [];
                currentLessons.forEach(lesson => {
                    if (lesson.vocabularies) {
                        lesson.vocabularies.forEach(vocab => {
                            allVocab.push({ ...vocab, lessonId: lesson.id });
                        });
                    }
                });
                setAllVocabularies(allVocab);
                console.log("All vocabularies for review pool updated:", allVocab);
            };

            // --- Lesson Handlers ---
            const handleCreateLessonSubmit = (e) => {
                e.preventDefault();
                if (!lessonName.trim()) {
                    setMessage({ text: "Tên bài học không được để trống.", type: "error" });
                    return;
                }

                const newLesson = {
                    id: Date.now().toString(),
                    name: lessonName,
                    createdAt: new Date(),
                    vocabularies: [],
                    passages: [],
                    courseId: lessonCourseId || (courses[0] ? courses[0].id : null)
                };

                setLessons(prevLessons => [...prevLessons, newLesson]);
                setMessage({ text: "Bài học đã được tạo thành công!", type: "success" });
                setLessonName('');
                setLessonCourseId('');
                setView('lessonList');
                console.log("Created new lesson locally:", newLesson);
            };

            const handleEditLesson = (lesson) => {
                setEditingLesson(lesson);
                setLessonName(lesson.name);
                setLessonCourseId(lesson.courseId);
                setView('editLesson');
                console.log("Entering edit lesson mode for:", lesson);
            };

            const handleUpdateLessonSubmit = (e) => {
                e.preventDefault();
                if (!editingLesson) return;
                if (!lessonName.trim()) {
                    setMessage({ text: "Tên bài học không được để trống.", type: "error" });
                    return;
                }

                setLessons(prevLessons =>
                    prevLessons.map(lesson =>
                        lesson.id === editingLesson.id
                            ? { ...lesson, name: lessonName, courseId: lessonCourseId, updatedAt: new Date() }
                            : lesson
                    )
                );
                setMessage({ text: "Tên bài học đã được cập nhật!", type: "success" });
                setLessonName('');
                setLessonCourseId('');
                setEditingLesson(null);
                setView('lessonList');
                console.log("Updated lesson name locally to:", lessonName);
            };

            const handleMoveLesson = (lessonId, direction) => {
                setLessons(prevLessons => {
                    const index = prevLessons.findIndex(lesson => lesson.id === lessonId);
                    if (index === -1) return prevLessons;
                    const courseId = prevLessons[index].courseId;
                    let targetIndex = index;
                    if (direction === 'up') {
                        for (let i = index - 1; i >= 0; i--) {
                            if (prevLessons[i].courseId === courseId) { targetIndex = i; break; }
                        }
                    } else if (direction === 'down') {
                        for (let i = index + 1; i < prevLessons.length; i++) {
                            if (prevLessons[i].courseId === courseId) { targetIndex = i; break; }
                        }
                    }
                    if (targetIndex !== index) {
                        const newLessons = [...prevLessons];
                        [newLessons[targetIndex], newLessons[index]] = [newLessons[index], newLessons[targetIndex]];
                        console.log("Moved lesson locally:", lessonId, "direction:", direction);
                        return newLessons;
                    }
                    return prevLessons;
                });
            };

            const handleChangeLessonCourse = (lessonId, newCourseId) => {
                setLessons(prevLessons => prevLessons.map(l => l.id === lessonId ? { ...l, courseId: newCourseId } : l));
            };

            const handleDeleteLesson = async (lessonId) => {
                if (window.confirm("Bạn có chắc muốn xóa bài học này và TẤT CẢ từ vựng & bài khóa bên trong không?")) {
                    console.log("Attempting to delete lesson:", lessonId);
                    const lessonToDelete = lessons.find(l => l.id === lessonId);
                    if (lessonToDelete) {
                        if (lessonToDelete.vocabularies) {
                            for (const vocab of lessonToDelete.vocabularies) {
                                if (vocab.audioFile) {
                                    await deleteAudioFile(vocab.audioFile);
                                    console.log("Deleted associated vocab audio from IndexedDB:", vocab.audioFile);
                                }
                                if (vocab.examples) {
                                    for (const ex of vocab.examples) {
                                        if (ex.audioFile) {
                                            await deleteAudioFile(ex.audioFile);
                                            console.log("Deleted associated example audio from IndexedDB:", ex.audioFile);
                                        }
                                    }
                                }
                            }
                        }
                        if (lessonToDelete.passages) {
                            for (const passage of lessonToDelete.passages) {
                                if (passage.sentences) {
                                    for (const sentence of passage.sentences) {
                                        if (sentence.audioFile) {
                                            await deleteAudioFile(sentence.audioFile);
                                            console.log("Deleted associated passage sentence audio from IndexedDB:", sentence.audioFile);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    setLessons(prevLessons => prevLessons.filter(lesson => lesson.id !== lessonId));
                    setMessage({ text: "Bài học, từ vựng và bài khóa đã được xóa thành công!", type: "success" });
                    if (selectedLesson && selectedLesson.id === lessonId) {
                        setSelectedLesson(null);
                        setView('lessonList');
                    }
                    console.log("Lesson deleted locally:", lessonId);
                }
            };

            // --- Course Handlers ---
            const handleCreateCourseSubmit = (e) => {
                e.preventDefault();
                if (!courseName.trim()) {
                    setMessage({ text: "Tên khoá học không được để trống.", type: "error" });
                    return;
                }
                const newCourse = { id: Date.now().toString(), name: courseName, expanded: true };
                setCourses(prev => [...prev, newCourse]);
                setCourseName('');
                setView('lessonList');
                setMessage({ text: "Khoá học đã được tạo!", type: "success" });
            };

            const handleEditCourse = (course) => {
                setEditingCourse(course);
                setCourseName(course.name);
                setView('editCourse');
            };

            const handleUpdateCourseSubmit = (e) => {
                e.preventDefault();
                if (!editingCourse) return;
                if (!courseName.trim()) {
                    setMessage({ text: "Tên khoá học không được để trống.", type: "error" });
                    return;
                }
                setCourses(prev => prev.map(c => c.id === editingCourse.id ? { ...c, name: courseName } : c));
                setCourseName('');
                setEditingCourse(null);
                setView('lessonList');
                setMessage({ text: "Khoá học đã được cập nhật!", type: "success" });
            };

            const handleDeleteCourse = (courseId) => {
                if (courses.length === 1) {
                    alert('Không thể xóa khoá học cuối cùng.');
                    return;
                }
                if (window.confirm("Xóa khoá học này? Các bài học sẽ được chuyển sang khoá đầu tiên.")) {
                    const newCourses = courses.filter(c => c.id !== courseId);
                    const targetId = newCourses[0].id;
                    setLessons(prev => prev.map(l => l.courseId === courseId ? { ...l, courseId: targetId } : l));
                    setCourses(newCourses);
                }
            };

            const handleMoveCourse = (courseId, direction) => {
                setCourses(prev => {
                    const index = prev.findIndex(c => c.id === courseId);
                    if (index === -1) return prev;
                    const newCourses = [...prev];
                    if (direction === 'up' && index > 0) {
                        [newCourses[index - 1], newCourses[index]] = [newCourses[index], newCourses[index - 1]];
                    } else if (direction === 'down' && index < newCourses.length - 1) {
                        [newCourses[index + 1], newCourses[index]] = [newCourses[index], newCourses[index + 1]];
                    }
                    return newCourses;
                });
            };

            const toggleCourseExpand = (courseId) => {
                setCourses(prev => prev.map(c => c.id === courseId ? { ...c, expanded: !c.expanded } : c));
            };

            // --- Vocabulary Handlers ---
            const handleAudioFileChange = (e, isExample = false, index = null) => {
                const file = e.target.files[0];
                if (!file) return;

                if (!file.type.startsWith('audio/')) {
                    setMessage({ text: "Vui lòng chọn một file âm thanh (MP3).", type: "error" });
                    if (e.target) e.target.value = '';
                    return;
                }

                if (isExample) {
                    const newExamples = [...examples];
                    newExamples[index] = { ...newExamples[index], audioFileBlob: file };
                    setExamples(newExamples);
                } else {
                    setAudioFileBlob(file);
                }
                console.log("Audio file selected:", file.name, "for example:", isExample, "index:", index);
            };

            const handleRemoveAudio = async (isExample = false, index = null) => {
                if (isExample) {
                    const newExamples = [...examples];
                    const audioIdToDelete = newExamples[index].audioFileId;

                    if (audioIdToDelete) {
                        await deleteAudioFile(audioIdToDelete);
                        console.log("Removed audio from IndexedDB:", audioIdToDelete);
                    }
                    newExamples[index] = { ...newExamples[index], audioFileBlob: null, audioFileId: null };
                    setExamples(newExamples);
                } else {
                    const audioIdToDelete = currentAudioFileId;
                    setAudioFileBlob(null);
                    setCurrentAudioFileId(null);

                    if (audioIdToDelete) {
                        await deleteAudioFile(audioIdToDelete);
                        console.log("Removed audio from IndexedDB:", audioIdToDelete);
                    }
                }
                console.log("Audio removed for example:", isExample, "index:", index);
            };

            const handleExampleChange = (index, field, value) => {
                const newExamples = [...examples];
                newExamples[index] = { ...newExamples[index], [field]: value };
                setExamples(newExamples);
            };

            const resetVocabularyForm = () => {
                setHanTu('');
                setPinyin('');
                setMeaning('');
                setHanVietMeaning('');
                setNotes('');
                setAudioFileBlob(null);
                setCurrentAudioFileId(null);
                setExamples(Array(6).fill({ chinese: '', vietnamese: '', audioFileBlob: null, audioFileId: null }));
                console.log("Vocabulary form reset.");
            };

            const processAndStoreAudio = async (fileBlob, oldAudioId = null) => {
                console.log("Processing audio file:", fileBlob, "old ID:", oldAudioId);
                if (fileBlob instanceof File) {
                    if (oldAudioId) {
                        await deleteAudioFile(oldAudioId);
                        console.log("Deleted old audio from IndexedDB:", oldAudioId);
                    }
                    const newAudioId = `audio-${Date.now()}-${Math.random().toString(36).substring(7)}`;
                    await storeAudioFile(newAudioId, fileBlob);
                    console.log("Stored new audio to IndexedDB:", newAudioId);
                    return newAudioId;
                } else if (fileBlob === null && oldAudioId) {
                    await deleteAudioFile(oldAudioId);
                    console.log("Removed audio from IndexedDB:", oldAudioId);
                    return null;
                } else if (typeof fileBlob === 'string') {
                    console.log("Keeping existing audio ID:", fileBlob);
                    return fileBlob;
                }
                console.log("No audio file to process.");
                return null;
            };


            const handleCreateVocabularySubmit = async (e) => {
                e.preventDefault();
                if (!selectedLesson || isProcessing) {
                    setMessage({ text: "Chưa chọn bài học hoặc đang xử lý. Vui lòng đợi.", type: "error" });
                    return;
                }
                if (!hanTu.trim() || !pinyin.trim() || !meaning.trim()) {
                    setMessage({ text: "Hán tự, Bính âm, Nghĩa tiếng Việt không được để trống.", type: "error" });
                    return;
                }

                setIsProcessing(true);
                console.log("Starting vocabulary creation process...");
                let vocabAudioId = null;
                try {
                    vocabAudioId = await processAndStoreAudio(audioFileBlob);
                } catch (e) {
                    setMessage({ text: `Lỗi lưu file âm thanh từ vựng: ${e.message}`, type: "error" });
                    setIsProcessing(false);
                    console.error("Error during main vocabulary audio storage:", e);
                    return;
                }

                const processedExamplesPromises = examples.map(async (ex, index) => {
                    let exampleAudioId = null;
                    if (ex.audioFileBlob instanceof File) {
                        try {
                            exampleAudioId = await processAndStoreAudio(ex.audioFileBlob);
                        } catch (e) {
                            setMessage({ text: `Lỗi lưu file âm thanh ví dụ ${index + 1}: ${e.message}`, type: "error" });
                            console.error(`Error during example ${index+1} audio storage:`, e);
                            throw e;
                        }
                    }
                    return { chinese: ex.chinese, vietnamese: ex.vietnamese, audioFile: exampleAudioId };
                });

                let processedExamples;
                try {
                    processedExamples = await Promise.all(processedExamplesPromises);
                } catch (e) {
                    setIsProcessing(false);
                    return;
                }

                const newVocabulary = {
                    id: Date.now().toString(),
                    hanTu,
                    pinyin,
                    meaning,
                    hanVietMeaning,
                    notes,
                    audioFile: vocabAudioId,
                    examples: processedExamples.filter(ex => ex.chinese || ex.vietnamese),
                    createdAt: new Date(),
                    wrongAttempts: 0,
                    correctStreak: 0
                };

                setLessons(prevLessons =>
                    prevLessons.map(lesson =>
                        lesson.id === selectedLesson.id
                            ? { ...lesson, vocabularies: [...(lesson.vocabularies || []), newVocabulary] }
                            : lesson
                    )
                );
                setMessage({ text: "Từ vựng đã được thêm vào bài học!", type: "success" });
                resetVocabularyForm();
                setView('vocabularyList');
                setIsProcessing(false);
                console.log("Vocabulary successfully created and added locally:", newVocabulary);
            };

            const handleEditVocabulary = (vocab) => {
                console.log("Entering edit vocabulary mode for:", vocab);
                setEditingVocab(vocab);
                setHanTu(vocab.hanTu);
                setPinyin(vocab.pinyin);
                setMeaning(vocab.meaning);
                setHanVietMeaning(vocab.hanVietMeaning || '');
                setNotes(vocab.notes);
                setCurrentAudioFileId(vocab.audioFile);
                setAudioFileBlob(null);
                
                const hydratedExamples = Array(6).fill({ chinese: '', vietnamese: '', audioFileBlob: null, audioFileId: null });

                (vocab.examples || []).forEach((ex, idx) => {
                    if (idx < 6) {
                        hydratedExamples[idx] = { 
                            chinese: ex.chinese, 
                            vietnamese: ex.vietnamese, 
                            audioFileBlob: null,
                            audioFileId: ex.audioFile
                        };
                    }
                });
                setExamples(hydratedExamples);
                setView('editVocabulary');
            };

            const handleUpdateVocabularySubmit = async (e) => {
                e.preventDefault();
                if (!editingVocab || !selectedLesson || isProcessing) {
                    setMessage({ text: "Chưa chọn bài học hoặc từ vựng để chỉnh sửa, hoặc đang xử lý. Vui lòng đợi.", type: "error" });
                    return;
                }
                if (!hanTu.trim() || !pinyin.trim() || !meaning.trim()) {
                    setMessage({ text: "Hán tự, Bính âm, Nghĩa tiếng Việt không được để trống.", type: "error" });
                    return;
                }

                setIsProcessing(true);
                console.log("Starting vocabulary update process for:", editingVocab.id);
                let updatedVocabAudioId = null;
                try {
                    updatedVocabAudioId = await processAndStoreAudio(audioFileBlob, currentAudioFileId);
                } catch (e) {
                    setMessage({ text: `Lỗi xử lý file âm thanh từ vựng: ${e.message}`, type: "error" });
                    setIsProcessing(false);
                    console.error("Error during main vocabulary audio update:", e);
                    return;
                }

                const updatedExamplesPromises = examples.map(async (ex, index) => {
                    let exampleAudioId = null;
                    const oldExampleAudioId = editingVocab.examples?.[index]?.audioFile || null;

                    if (ex.chinese || ex.vietnamese) {
                         exampleAudioId = await processAndStoreAudio(ex.audioFileBlob, oldExampleAudioId);
                    } else if (oldExampleAudioId) {
                        await deleteAudioFile(oldExampleAudioId);
                        console.log("Deleted old example audio because example is now empty:", oldExampleAudioId);
                    }
                    return { chinese: ex.chinese, vietnamese: ex.vietnamese, audioFile: exampleAudioId };
                });

                let processedExamples;
                try {
                    processedExamples = await Promise.all(updatedExamplesPromises);
                } catch (e) {
                    setIsProcessing(false);
                    return;
                }

                const updatedVocabulary = {
                    ...editingVocab,
                    hanTu,
                    pinyin,
                    meaning,
                    hanVietMeaning,
                    notes,
                    audioFile: updatedVocabAudioId,
                    examples: processedExamples.filter(ex => ex.chinese || ex.vietnamese),
                    updatedAt: new Date(),
                };

                setLessons(prevLessons =>
                    prevLessons.map(lesson =>
                        lesson.id === selectedLesson.id
                            ? {
                                ...lesson,
                                vocabularies: (lesson.vocabularies || []).map(vocab =>
                                    vocab.id === updatedVocabulary.id ? updatedVocabulary : vocab
                                )
                            }
                            : lesson
                    )
                );
                setMessage({ text: "Từ vựng đã được cập nhật thành công!", type: "success" });
                resetVocabularyForm();
                setEditingVocab(null);
                setView('vocabularyList');
                setIsProcessing(false);
                console.log("Vocabulary successfully updated locally:", updatedVocabulary);
            };


            const handleDeleteVocabulary = async (vocabId) => {
                if (window.confirm("Bạn có chắc muốn xóa từ vựng này không?")) {
                    setIsProcessing(true);
                    console.log("Starting vocabulary deletion process for:", vocabId);
                    const lessonIndex = lessons.findIndex(l => l.id === selectedLesson.id);
                    if (lessonIndex === -1) { setIsProcessing(false); return; }

                    const vocabToDelete = lessons[lessonIndex].vocabularies.find(v => v.id === vocabId);
                    if (vocabToDelete) {
                        if (vocabToDelete.audioFile) {
                            await deleteAudioFile(vocabToDelete.audioFile);
                            console.log("Deleted associated audio from IndexedDB:", vocabToDelete.audioFile);
                        }
                        if (vocabToDelete.examples) {
                            for (const ex of vocabToDelete.examples) {
                                if (ex.audioFile) {
                                    await deleteAudioFile(ex.audioFile);
                                    console.log("Deleted example audio from IndexedDB:", ex.audioFile);
                                }
                            }
                        }
                    }

                    setLessons(prevLessons =>
                        prevLessons.map(lesson =>
                            lesson.id === selectedLesson.id
                                ? { ...lesson, vocabularies: (lesson.vocabularies || []).filter(vocab => vocab.id !== vocabId) }
                                : lesson
                        )
                    );
                    setMessage({ text: "Từ vựng đã được xóa thành công!", type: "success" });
                    setIsProcessing(false);
                    console.log("Vocabulary deleted locally:", vocabId);
                }
            };

            // --- Game Logic ---
            const shuffleArray = (array) => {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            };

            const playQuestionAudio = async (questionData) => {
                let audioIdToPlay = null;
                let textToSpeak = "";
                
                if (questionData.type === 'translateExample' || questionData.type === 'rearrangeExample') {
                    audioIdToPlay = questionData.exampleAudioId;
                    textToSpeak = questionData.text;
                } 
                else if (questionData.vocab) { 
                    audioIdToPlay = questionData.vocab.audioFile;
                    textToSpeak = questionData.vocab.hanTu;
                }

                if (textToSpeak) {
                    speakText(textToSpeak, audioIdToPlay);
                } else {
                    console.warn("No text to speak for this question type or vocab.");
                }
            };

            const handlePlayDetailAudio = (audioId, textToSpeak = "") => {
                speakText(textToSpeak, audioId);
            };

            const normalizePinyin = (pinyinString) => {
                return pinyinString
                    .normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, "")
                    .replace(/\s+/g, '')
                    .toLowerCase();
            };
            
            const normalizeHanTu = (hanTuString) => {
                return hanTuString.replace(/[^\u4e00-\u9fff\u3400-\u4DBF]/g, ''); 
            };
            
            const splitChineseSentence = (sentence) => {
                return sentence.split(/\s+|(?=[\u4e00-\u9fff])|(?<=[\u4e00-\u9fff])/).filter(word => word.trim() !== '');
            };


            const displayQuestion = async (questionIndex, vocabList) => {
                if (!vocabList || vocabList.length === 0 || questionIndex >= vocabList.length) {
                    setQuestion(null);
                    return;
                }

                const questionVocab = vocabList[questionIndex];
                
                let questionData = {};
                let allOptionsCombined = [];
                let correctOption = null;
                let correctIdx = -1;

                let currentVocabSuitableExamples = questionVocab.examples ? questionVocab.examples.filter(ex => ex.chinese && splitChineseSentence(ex.chinese).length > 1) : [];

                const availableQuestionTypes = [];

                if (questionVocab.meaning) {
                    availableQuestionTypes.push('translateWord');
                }
                
                if (questionVocab.pinyin) {
                    availableQuestionTypes.push('typePinyin');
                }

                const uniqueVietMeaningsForMC = [...new Set(allVocabularies.map(v => v.meaning))].filter(m => m && m !== questionVocab.meaning);
                if (questionVocab.hanTu && uniqueVietMeaningsForMC.length >= 3) {
                    availableQuestionTypes.push('translateMeaning');
                }
                
                const otherHanTusForMC = [...new Set(allVocabularies.map(v => v.hanTu))].filter(h => h && h !== questionVocab.hanTu);
                if (questionVocab.meaning && questionVocab.hanTu && otherHanTusForMC.length >= 3) {
                    availableQuestionTypes.push('translateVietToHanTuMC');
                }

                if (currentVocabSuitableExamples.length > 0) {
                    availableQuestionTypes.push('translateExample');
                }
                
                if (questionVocab.hanTu && questionVocab.meaning) {
                     availableQuestionTypes.push('typeHanTu');
                }

                if (currentVocabSuitableExamples.length > 0) {
                    availableQuestionTypes.push('rearrangeExample');
                }


                if (availableQuestionTypes.length === 0) {
                    console.warn("No suitable question types available for this vocabulary.", questionVocab);
                    setMessage({ text: "Từ vựng này không có đủ thông tin để tạo câu hỏi. Chuyển sang câu hỏi khác hoặc hoàn thành.", type: "info" });
                    setQuestion(null);
                    return;
                }
                
                const randomQuestionType = shuffleArray(availableQuestionTypes)[0];
                setQuestionType(randomQuestionType);
                setPinyinInput('');
                setHanTuInput('');
                setSelectedOption(null);
                setIsCorrect(null);
                setScrambledWords([]);
                setSelectedWords([]);
                setRearrangeIsAnswered(false);

                console.log("Selected question type:", randomQuestionType, "for vocab:", questionVocab.hanTu);

                switch (randomQuestionType) {
                    case 'translateWord':
                        questionData = {
                            vocab: questionVocab,
                            text: questionVocab.hanTu,
                            type: 'translateWord',
                            pinyin: questionVocab.pinyin
                        };
                        correctOption = questionVocab.meaning;
                        
                        let wrongMeanings = [];
                        const meaningPool = allVocabularies.filter(v => v.id !== questionVocab.id && v.meaning);
                        const uniqueMeaningPool = [...new Set(meaningPool.map(v => v.meaning))].filter(m => m && m !== correctOption);

                        while (wrongMeanings.length < 3 && uniqueMeaningPool.length > 0) {
                            const randomIndex = Math.floor(Math.random() * uniqueMeaningPool.length);
                            wrongMeanings.push(uniqueMeaningPool.splice(randomIndex, 1)[0]);
                        }
                        while (wrongMeanings.length < 3) {
                            wrongMeanings.push(`Đáp án sai ${wrongMeanings.length + 1}`);
                        }
                        allOptionsCombined = shuffleArray([correctOption, ...wrongMeanings]);
                        correctIdx = allOptionsCombined.indexOf(correctOption);
                        break;

                    case 'typePinyin':
                        questionData = {
                            vocab: questionVocab,
                            text: questionVocab.hanTu,
                            type: 'typePinyin',
                            correctAnswer: normalizePinyin(questionVocab.pinyin),
                            displayPinyin: questionVocab.pinyin
                        };
                        break;
                    
                    case 'translateMeaning':
                        questionData = {
                            vocab: questionVocab,
                            text: questionVocab.hanTu,
                            type: 'translateMeaning',
                        };
                        correctOption = questionVocab.meaning;
                        
                        let wrongMeaningsForHanTu = [];
                        const meaningPoolForHanTu = allVocabularies.filter(v => v.id !== questionVocab.id && v.meaning);
                        const uniqueMeaningPoolForHanTu = [...new Set(meaningPoolForHanTu.map(v => v.meaning))].filter(m => m && m !== correctOption);

                        while (wrongMeaningsForHanTu.length < 3 && uniqueMeaningPoolForHanTu.length > 0) {
                            const randomIndex = Math.floor(Math.random() * uniqueMeaningPoolForHanTu.length);
                            wrongMeaningsForHanTu.push(uniqueMeaningPoolForHanTu.splice(randomIndex, 1)[0]);
                        }
                        while (wrongMeaningsForHanTu.length < 3) {
                            wrongMeaningsForHanTu.push(`Nghĩa sai ${wrongMeaningsForHanTu.length + 1}`);
                        }
                        allOptionsCombined = shuffleArray([correctOption, ...wrongMeaningsForHanTu]);
                        correctIdx = allOptionsCombined.indexOf(correctOption);
                        break;
                    
                    case 'translateVietToHanTuMC':
                        questionData = {
                            vocab: questionVocab,
                            text: questionVocab.meaning,
                            type: 'translateVietToHanTuMC',
                        };
                        correctOption = questionVocab.hanTu;
                        
                        let wrongHanTusMC = [];
                        const hanTuPoolMC = allVocabularies.filter(v => v.id !== questionVocab.id && v.hanTu);
                        const uniqueHanTuPoolMC = [...new Set(hanTuPoolMC.map(v => v.hanTu))].filter(h => h && h !== correctOption);

                        while (wrongHanTusMC.length < 3 && uniqueHanTuPoolMC.length > 0) {
                            const randomIndex = Math.floor(Math.random() * uniqueHanTuPoolMC.length);
                            wrongHanTusMC.push(uniqueHanTuPoolMC.splice(randomIndex, 1)[0]);
                        }
                        while (wrongHanTusMC.length < 3) {
                            wrongHanTusMC.push(`Chữ sai ${wrongHanTusMC.length + 1}`);
                        }
                        allOptionsCombined = shuffleArray([correctOption, ...wrongHanTusMC]);
                        correctIdx = allOptionsCombined.indexOf(correctOption);
                        break;

                    case 'translateExample':
                        const selectedExample = shuffleArray(currentVocabSuitableExamples)[0];

                        questionData = {
                            vocab: questionVocab,
                            example: selectedExample,
                            text: selectedExample.chinese,
                            type: 'translateExample',
                            exampleAudioId: selectedExample.audioFile
                        };
                        correctOption = selectedExample.vietnamese;

                        let wrongExampleMeanings = [];
                        const allExampleMeaningPool = allVocabularies.flatMap(v => 
                            v.examples ? v.examples.map(ex => ex.vietnamese) : []
                        ).filter(m => m && m !== correctOption);
                        
                        const uniqueExampleMeaningPool = [...new Set(allExampleMeaningPool)].filter(m => m && m !== correctOption);

                        while (wrongExampleMeanings.length < 3 && uniqueExampleMeaningPool.length > 0) {
                            const randomIndex = Math.floor(Math.random() * uniqueExampleMeaningPool.length);
                            wrongExampleMeanings.push(uniqueExampleMeaningPool.splice(randomIndex, 1)[0]);
                        }
                        while (wrongExampleMeanings.length < 3) {
                            wrongExampleMeanings.push(`Dịch sai ${wrongExampleMeanings.length + 1}`);
                        }
                        allOptionsCombined = shuffleArray([correctOption, ...wrongExampleMeanings]);
                        correctIdx = allOptionsCombined.indexOf(correctOption);
                        break;
                    
                    case 'typeHanTu':
                        questionData = {
                            vocab: questionVocab,
                            text: questionVocab.meaning,
                            type: 'typeHanTu',
                            correctAnswer: normalizeHanTu(questionVocab.hanTu),
                            displayHanTu: questionVocab.hanTu
                        };
                        break;

                    default:
                        console.error("Undefined question type encountered:", randomQuestionType);
                        setQuestionType('translateWord'); 
                        displayQuestion(questionIndex, vocabList); 
                        return;
                }

                setQuestion(questionData);
                setOptions(allOptionsCombined);
                setCorrectAnswerIndex(correctIdx);
                setShaking(false);

                playQuestionAudio(questionData);
                console.log("Displayed question for review:", questionData);
            };

            const promptForReviewLimit = (mode, lesson = null, isDifficult = false) => {
                setReviewMode(mode);
                setSelectedLesson(lesson);
                setTempReviewLimit('');
                setShowReviewLimitModal({ isVisible: true, isDifficult: isDifficult });
            };

            const handleStartReviewFromModal = () => {
                const limit = parseInt(tempReviewLimit, 10);
                let actualLimit = limit;
                const { isVisible, isDifficult } = showReviewLimitModal;

                let vocabForReview = [];
                if (isDifficult) {
                    vocabForReview = allVocabularies.filter(vocab => vocab.wrongAttempts && vocab.wrongAttempts >= 2);
                    if (vocabForReview.length === 0) {
                        setMessage({ text: "Chưa có từ vựng khó nào để ôn tập. Hãy thử làm sai một vài lần!", type: "info" });
                        setShowReviewLimitModal({ isVisible: false, isDifficult: false });
                        return;
                    }
                } else if (reviewMode === 'allLessons') {
                    vocabForReview = allVocabularies;
                } else if (reviewMode === 'singleLesson' && selectedLesson) {
                    vocabForReview = allVocabularies.filter(v => v.lessonId === selectedLesson.id);
                }

                const validVocabForReview = vocabForReview.filter(vocab => 
                    vocab.meaning || 
                    vocab.pinyin || 
                    (vocab.examples && vocab.examples.some(ex => ex.chinese && ex.vietnamese && splitChineseSentence(ex.chinese).length > 1))
                );

                if (validVocabForReview.length === 0) {
                    setMessage({ text: "Chưa có từ vựng nào có đủ thông tin (nghĩa, bính âm, ví dụ) để ôn tập trong lựa chọn này. Vui lòng tạo từ vựng đầy đủ hơn.", type: "error" });
                    setShowReviewLimitModal({ isVisible: false, isDifficult: false });
                    return;
                }

                setReviewSourceVocabs(shuffleArray(validVocabForReview));

                if (isNaN(actualLimit) || actualLimit <= 0) {
                    actualLimit = validVocabForReview.length;
                }
                
                let questionsToAsk = [];
                let currentPool = [];
                for (let i = 0; i < actualLimit; i++) {
                    if (currentPool.length === 0) {
                        currentPool = shuffleArray([...validVocabForReview]);
                    }
                    if (currentPool.length > 0) {
                        questionsToAsk.push(currentPool.pop());
                    } else {
                        break; 
                    }
                }
                
                setReviewVocabList(questionsToAsk);
                setTotalQuestions(questionsToAsk.length);
                setScore(0);
                setCurrentQuestionNumber(0);
                displayQuestion(0, questionsToAsk);
                setView('review');
                setShowReviewLimitModal({ isVisible: false, isDifficult: false });
                console.log(`Review session started with total questions:`, questionsToAsk.length);
            };


            const handleOptionClick = async (index) => {
                if (selectedOption !== null) return;

                setSelectedOption(index);
                if (index === correctAnswerIndex) {
                    setIsCorrect(true);
                    setScore(prev => prev + 1);
                    const vocabId = question.vocab.id;
                    setLessons(prevLessons => 
                        prevLessons.map(lesson => ({
                            ...lesson,
                            vocabularies: lesson.vocabularies.map(vocab => {
                                if (vocab.id === vocabId) {
                                    const newCorrectStreak = (vocab.correctStreak || 0) + 1;
                                    return { 
                                        ...vocab, 
                                        correctStreak: newCorrectStreak,
                                        wrongAttempts: newCorrectStreak >= CORRECT_STREAK_TO_GRADUATE ? 0 : vocab.wrongAttempts
                                    };
                                }
                                return vocab;
                            })
                        }))
                    );
                    playQuestionAudio(question);
                    console.log("Answer correct. Score:", score + 1);
                } else {
                    setIsCorrect(false);
                    setShaking(true);
                    console.log("Answer incorrect.");
                    const vocabId = question.vocab.id;
                    setLessons(prevLessons => 
                        prevLessons.map(lesson => ({
                            ...lesson,
                            vocabularies: lesson.vocabularies.map(vocab => 
                                vocab.id === vocabId ? { 
                                    ...vocab, 
                                    wrongAttempts: (vocab.wrongAttempts || 0) + 1,
                                    correctStreak: 0
                                } : vocab
                            )
                        }))
                    );
                }
            };
            
            const handlePinyinSubmit = async (e) => {
                e.preventDefault();
                if (isCorrect !== null) return;

                const submittedPinyin = normalizePinyin(pinyinInput);
                const correctPinyin = question.correctAnswer;

                if (submittedPinyin === correctPinyin) {
                    setIsCorrect(true);
                    setScore(prev => prev + 1);
                    const vocabId = question.vocab.id;
                    setLessons(prevLessons => 
                        prevLessons.map(lesson => ({
                            ...lesson,
                            vocabularies: lesson.vocabularies.map(vocab => {
                                if (vocab.id === vocabId) {
                                    const newCorrectStreak = (vocab.correctStreak || 0) + 1;
                                    return { 
                                        ...vocab, 
                                        correctStreak: newCorrectStreak,
                                        wrongAttempts: newCorrectStreak >= CORRECT_STREAK_TO_GRADUATE ? 0 : vocab.wrongAttempts
                                    };
                                }
                                return vocab;
                            })
                        }))
                    );
                    playQuestionAudio(question);
                    console.log("Pinyin answer correct. Score:", score + 1);
                } else {
                    setIsCorrect(false);
                    setShaking(true);
                    console.log("Pinyin answer incorrect.");
                    const vocabId = question.vocab.id;
                    setLessons(prevLessons => 
                        prevLessons.map(lesson => ({
                            ...lesson,
                            vocabularies: lesson.vocabularies.map(vocab => 
                                vocab.id === vocabId ? { 
                                    ...vocab, 
                                    wrongAttempts: (vocab.wrongAttempts || 0) + 1,
                                    correctStreak: 0
                                } : vocab
                            )
                        }))
                    );
                }
            };

            const handleHanTuSubmit = async (e) => {
                e.preventDefault();
                if (isCorrect !== null) return;

                const submittedHanTu = normalizeHanTu(hanTuInput);
                const correctHanTu = normalizeHanTu(question.correctAnswer);

                if (submittedHanTu === correctHanTu) {
                    setIsCorrect(true);
                    setScore(prev => prev + 1);
                    const vocabId = question.vocab.id;
                    setLessons(prevLessons => 
                        prevLessons.map(lesson => ({
                            ...lesson,
                            vocabularies: lesson.vocabularies.map(vocab => {
                                if (vocab.id === vocabId) {
                                    const newCorrectStreak = (vocab.correctStreak || 0) + 1;
                                    return { 
                                        ...vocab, 
                                        correctStreak: newCorrectStreak,
                                        wrongAttempts: newCorrectStreak >= CORRECT_STREAK_TO_GRADUATE ? 0 : vocab.wrongAttempts
                                    };
                                }
                                return vocab;
                            })
                        }))
                    );
                    playQuestionAudio(question);
                    console.log("HanTu answer correct. Score:", score + 1);
                } else {
                    setIsCorrect(false);
                    setShaking(true);
                    console.log("HanTu answer incorrect.");
                    const vocabId = question.vocab.id;
                    setLessons(prevLessons => 
                        prevLessons.map(lesson => ({
                            ...lesson,
                            vocabularies: lesson.vocabularies.map(vocab => 
                                vocab.id === vocabId ? { 
                                    ...vocab, 
                                    wrongAttempts: (vocab.wrongAttempts || 0) + 1,
                                    correctStreak: 0
                                } : vocab
                            )
                        }))
                    );
                }
            };

            const handleWordClick = (item, indexInScrambled) => {
                if (rearrangeIsAnswered) return;
                
                setSelectedWords(prev => [...prev, item.word]);
                setScrambledWords(prev => prev.map((wordObj, i) => 
                    i === indexInScrambled ? { ...wordObj, isUsed: true } : wordObj
                ));
            };

            const handleRearrangeCheck = async () => {
                if (rearrangeIsAnswered) return;

                const userAnswer = selectedWords.join('');
                const correctAnswer = question.correctSequence.join('');

                if (userAnswer === correctAnswer) {
                    setIsCorrect(true);
                    setScore(prev => prev + 1);
                    setRearrangeIsAnswered(true);
                    playQuestionAudio(question);
                    const vocabId = question.vocab.id;
                    setLessons(prevLessons => 
                        prevLessons.map(lesson => ({
                            ...lesson,
                            vocabularies: lesson.vocabularies.map(vocab => {
                                if (vocab.id === vocabId) {
                                    const newCorrectStreak = (vocab.correctStreak || 0) + 1;
                                    return { 
                                        ...vocab, 
                                        correctStreak: newCorrectStreak,
                                        wrongAttempts: newCorrectStreak >= CORRECT_STREAK_TO_GRADUATE ? 0 : vocab.wrongAttempts
                                    };
                                }
                                return vocab;
                            })
                        }))
                    );
                } else {
                    setIsCorrect(false);
                    setShaking(true);
                    const vocabId = question.vocab.id;
                    setLessons(prevLessons => 
                        prevLessons.map(lesson => ({
                            ...lesson,
                            vocabularies: lesson.vocabularies.map(vocab => 
                                vocab.id === vocabId ? { 
                                    ...vocab, 
                                    wrongAttempts: (vocab.wrongAttempts || 0) + 1,
                                    correctStreak: 0
                                } : vocab
                            )
                        }))
                    );
                }
            };

            const handleRearrangeReset = () => {
                setSelectedWords([]);
                setScrambledWords(prev => prev.map(wordObj => ({ ...wordObj, isUsed: false })));
                setIsCorrect(null);
                setShaking(false);
            };

            const handleRearrangeGiveUp = async () => {
                setRearrangeIsAnswered(true);
                setIsCorrect(false);
                setSelectedWords(question.correctSequence);
                setScrambledWords(prev => prev.map(wordObj => ({ ...wordObj, isUsed: true }))); 
                playQuestionAudio(question);
                const vocabId = question.vocab.id;
                setLessons(prevLessons => 
                    prevLessons.map(lesson => ({
                        ...lesson,
                        vocabularies: lesson.vocabularies.map(vocab => 
                            vocab.id === vocabId ? { 
                                ...vocab, 
                                wrongAttempts: (vocab.wrongAttempts || 0) + 1,
                                correctStreak: 0
                            } : vocab
                        )
                    }))
                );
            };


            const handleNextQuestion = () => {
                const nextQuestionIndex = currentQuestionNumber + 1;
                if (nextQuestionIndex < totalQuestions) {
                    setCurrentQuestionNumber(nextQuestionIndex);
                    displayQuestion(nextQuestionIndex, reviewVocabList);
                    console.log("Moving to next question:", nextQuestionIndex);
                } else {
                    setMessage({ text: `Hoàn thành ôn tập! Bạn đã trả lời đúng ${score} / ${totalQuestions} câu.`, type: "success" });
                    setView('lessonList');
                    setSelectedOption(null);
                    setIsCorrect(null);
                    setQuestion(null);
                    setReviewVocabList([]);
                    setPinyinInput('');
                    setHanTuInput('');
                    setReviewSourceVocabs([]);
                    setScrambledWords([]);
                    setSelectedWords([]);
                    setRearrangeIsAnswered(false);
                    console.log("Review session completed.");
                }
            };
            
            // --- Export Data Feature ---
            const handleExportData = async () => {
                setIsProcessing(true);
                console.log("Starting data export...");
                try {
                    const allAudioBlobs = await getAllAudioFiles();
                    console.log("Fetched all audio blobs for export:", allAudioBlobs.length);

                    const exportableLessonsPromises = lessons.map(async lesson => ({
                        ...lesson,
                        vocabularies: await Promise.all((lesson.vocabularies || []).map(async vocab => {
                            const vocabAudioBlobData = allAudioBlobs.find(a => a.id === vocab.audioFile)?.data;
                            const serializableExamplesPromises = (vocab.examples || []).map(async ex => {
                                const exampleAudioBlobData = allAudioBlobs.find(a => a.id === ex.audioFile)?.data;
                                return {
                                    ...ex,
                                    audioFileBase64: exampleAudioBlobData ? await new Promise(resolve => {
                                        const reader = new FileReader();
                                        reader.onloadend = () => resolve(reader.result);
                                        reader.readAsDataURL(exampleAudioBlobData);
                                    }) : null
                                };
                            });
                            return {
                                ...vocab,
                                audioFileBase64: vocabAudioBlobData ? await new Promise(resolve => {
                                    const reader = new FileReader();
                                    reader.onloadend = () => resolve(reader.result);
                                    reader.readAsDataURL(vocabAudioBlobData);
                                }) : null,
                                examples: await Promise.all(serializableExamplesPromises),
                                wrongAttempts: vocab.wrongAttempts || 0,
                                correctStreak: vocab.correctStreak || 0,
                                hanVietMeaning: vocab.hanVietMeaning || ''
                            };
                        })),
                        passages: await Promise.all((lesson.passages || []).map(async passage => ({
                            ...passage,
                            sentences: await Promise.all((passage.sentences || []).map(async sentence => {
                                const sentenceAudioBlobData = allAudioBlobs.find(a => a.id === sentence.audioFile)?.data;
                                return {
                                    ...sentence,
                                    audioFileBase64: sentenceAudioBlobData ? await new Promise(resolve => {
                                        const reader = new FileReader();
                                        reader.onloadend = () => resolve(reader.result);
                                        reader.readAsDataURL(sentenceAudioBlobData);
                                    }) : null
                                };
                            }))
                        })))
                    }));
                    
                    const lessonsWithResolvedAudio = await Promise.all(exportableLessonsPromises);
                    console.log("Lessons with resolved audio for export:", lessonsWithResolvedAudio);

                    const dataToExport = {
                        appId: "ChineseVocabApp_Local",
                        version: "1.0",
                        timestamp: new Date().toISOString(),
                        courses: courses,
                        lessons: lessonsWithResolvedAudio,
                        studyGoal: {
                            targetDate: targetDate,
                            checkInStreak: checkInStreak,
                            lastCheckInDate: lastCheckInDate ? lastCheckInDate.toISOString() : null,
                        }
                    };

                    const jsonString = JSON.stringify(dataToExport, null, 2);
                    const blob = new Blob([jsonString], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `chinese_vocab_backup_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    setMessage({ text: "Dữ liệu đã được xuất thành công!", type: "success" });
                    console.log("Data export successful!");
                } catch (e) {
                    console.error("Error exporting data:", e);
                    setMessage({ text: `Lỗi khi xuất dữ liệu: ${e.message}. Vui lòng kiểm tra console.`, type: "error" });
                } finally {
                    setIsProcessing(false);
                }
            };

            // --- Import Data Feature ---
            const handleImportData = async (e) => {
                const file = e.target.files[0];
                if (!file) {
                    if (e.target) e.target.value = '';
                    return;
                }

                if (window.confirm("Thao tác này sẽ XÓA TOÀN BỘ dữ liệu hiện có và thay thế bằng dữ liệu từ file. Bạn có chắc chắn muốn tiếp tục không?")) {
                    setIsProcessing(true);
                    console.log("Starting data import process...");
                    try {
                        const reader = new FileReader();
                        reader.onload = async (event) => {
                            try {
                                const importedData = JSON.parse(event.target.result);
                                console.log("Parsed imported data:", importedData);

                                if (importedData.appId !== "ChineseVocabApp_Local" || !importedData.lessons) {
                                    throw new Error("File JSON không hợp lệ hoặc không phải là file backup của ứng dụng này.");
                                }

                                console.log("Clearing existing localStorage and IndexedDB data...");
                                localStorage.removeItem(LOCAL_STORAGE_KEY);
                                localStorage.removeItem(COURSE_STORAGE_KEY);
                                localStorage.removeItem('chineseTargetDate');
                                localStorage.removeItem('chineseCheckInStreak');
                                localStorage.removeItem('chineseLastCheckInDate');
                                await clearAllAudioFiles();

                                const importedCourses = (importedData.courses && importedData.courses.length > 0)
                                    ? importedData.courses
                                    : [{ id: `course-${Date.now()}`, name: 'Khoá học mặc định', expanded: true }];

                                const newLessons = [];
                                for (const lessonData of importedData.lessons) {
                                    const newVocabularies = [];
                                    for (const vocabData of lessonData.vocabularies) {
                                        let vocabAudioId = vocabData.audioFile;
                                        if (vocabData.audioFileBase64) {
                                            console.log("Processing main vocab audio Base64 for import...");
                                            const base64String = vocabData.audioFileBase64.split(',')[1];
                                            const mimeType = vocabData.audioFileBase64.split(',')[0].split(':')[1].split(';')[0];
                                            const byteCharacters = atob(base64String);
                                            const byteNumbers = new Array(byteCharacters.length);
                                            for (let i = 0; i < byteCharacters.length; i++) {
                                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                                            }
                                            const byteArray = new Uint8Array(byteNumbers);
                                            const audioBlob = new Blob([byteArray], { type: mimeType });

                                            vocabAudioId = `audio-${Date.now()}-${Math.random().toString(36).substring(7)}`; 
                                            await storeAudioFile(vocabAudioId, audioBlob);
                                            console.log("Stored imported main vocab audio to IndexedDB:", vocabAudioId);
                                        }

                                        const newExamples = [];
                                        for (const exData of (vocabData.examples || [])) {
                                            let exampleAudioId = exData.audioFile;
                                            if (exData.audioFileBase64) {
                                                console.log("Processing example audio Base64 for import...");
                                                const base64String = exData.audioFileBase64.split(',')[1];
                                                const mimeType = exData.audioFileBase64.split(',')[0].split(':')[1].split(';')[0];
                                                const byteCharacters = atob(base64String);
                                                const byteNumbers = new Array(byteCharacters.length);
                                                for (let i = 0; i < byteCharacters.length; i++) {
                                                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                                                }
                                                const byteArray = new Uint8Array(byteNumbers);
                                                const audioBlob = new Blob([byteArray], { type: mimeType });

                                                exampleAudioId = `example-audio-${Date.now()}-${Math.random().toString(36).substring(7)}`; 
                                                await storeAudioFile(exampleAudioId, audioBlob);
                                                console.log("Stored imported example audio to IndexedDB:", exampleAudioId);
                                            }
                                            newExamples.push({ ...exData, audioFile: exampleAudioId });
                                        }
                                        const vocabCreatedAt = safeParseDate(vocabData.createdAt) || new Date();
                                        const vocabUpdatedAt = safeParseDate(vocabData.updatedAt);
                                        newVocabularies.push({ 
                                            ...vocabData, 
                                            audioFile: vocabAudioId, 
                                            examples: newExamples,
                                            createdAt: vocabCreatedAt,
                                            ...(vocabUpdatedAt && { updatedAt: vocabUpdatedAt }),
                                            wrongAttempts: vocabData.wrongAttempts || 0,
                                            correctStreak: vocabData.correctStreak || 0,
                                            hanVietMeaning: vocabData.hanVietMeaning || ''
                                        });
                                    }
                                    const newPassages = [];
                                    for (const passageData of (lessonData.passages || [])) {
                                        const newSentences = [];
                                        for (const sentenceData of (passageData.sentences || [])) {
                                            let sentenceAudioId = sentenceData.audioFile;
                                            if (sentenceData.audioFileBase64) {
                                                console.log("Processing passage sentence audio Base64 for import...");
                                                const base64String = sentenceData.audioFileBase64.split(',')[1];
                                                const mimeType = sentenceData.audioFileBase64.split(',')[0].split(':')[1].split(';')[0];
                                                const byteCharacters = atob(base64String);
                                                const byteNumbers = new Array(byteCharacters.length);
                                                for (let i = 0; i < byteCharacters.length; i++) {
                                                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                                                }
                                                const byteArray = new Uint8Array(byteNumbers);
                                                const audioBlob = new Blob([byteArray], { type: mimeType });
                                                sentenceAudioId = `passage-audio-${Date.now()}-${Math.random().toString(36).substring(7)}`;
                                                await storeAudioFile(sentenceAudioId, audioBlob);
                                                console.log("Stored imported passage sentence audio to IndexedDB:", sentenceAudioId);
                                            }
                                            newSentences.push({ ...sentenceData, audioFile: sentenceAudioId, speaker: sentenceData.speaker || '' });
                                        }
                                        newPassages.push({ ...passageData, sentences: newSentences });
                                    }

                                    const lessonCreatedAt = safeParseDate(lessonData.createdAt) || new Date();
                                    const lessonUpdatedAt = safeParseDate(lessonData.updatedAt);
                                    newLessons.push({
                                        ...lessonData,
                                        courseId: lessonData.courseId || importedCourses[0].id,
                                        vocabularies: newVocabularies,
                                        passages: newPassages,
                                        createdAt: lessonCreatedAt,
                                        ...(lessonUpdatedAt && { updatedAt: lessonUpdatedAt })
                                    });
                                }

                                setCourses(importedCourses);
                                setLessons(newLessons);

                                if (importedData.studyGoal) {
                                    setTargetDate(importedData.studyGoal.targetDate || '');
                                    localStorage.setItem('chineseTargetDate', importedData.studyGoal.targetDate || '');
                                    calculateDaysRemaining(importedData.studyGoal.targetDate || '');

                                    setCheckInStreak(importedData.studyGoal.checkInStreak || 0);
                                    localStorage.setItem('chineseCheckInStreak', importedData.studyGoal.checkInStreak || 0);

                                    const importedLastCheckInDate = importedData.studyGoal.lastCheckInDate ? new Date(importedData.studyGoal.lastCheckInDate) : null;
                                    setLastCheckInDate(importedLastCheckInDate);
                                    localStorage.setItem('chineseLastCheckInDate', importedLastCheckInDate ? importedLastCheckInDate.toISOString() : '');
                                }

                                setMessage({ text: "Dữ liệu đã được nhập thành công!", type: "success" });
                                console.log("Data import successful! New lessons set:", newLessons);
                            } catch (parseError) {
                                console.error("Error parsing/processing imported JSON:", parseError);
                                setMessage({ text: `Lỗi khi xử lý file nhập: ${parseError.message}. Vui lòng kiểm tra file.`, type: "error" });
                            } finally {
                                setIsProcessing(false);
                                if (e.target) e.target.value = '';
                            }
                        };
                        reader.readAsText(file);
                    } catch (e) {
                        console.error("Error reading import file:", e);
                        setMessage({ text: `Lỗi khi đọc file nhập: ${e.message}.`, type: "error" });
                        setIsProcessing(false);
                        if (e.target) e.target.value = '';
                    }
                } else {
                    if (e.target) e.target.value = '';
                }
            };

            // NEW: Handle Import from HTML File
            const handleImportFromHtmlFile = (e) => {
                const file = e.target.files[0];
                if (!file) {
                    if (e.target) e.target.value = '';
                    return;
                }

                if (!file.name.toLowerCase().endsWith('.html')) {
                    setMessage({ text: "Vui lòng chọn một file HTML hợp lệ.", type: "error" });
                    if (e.target) e.target.value = '';
                    return;
                }

                setIsProcessing(true);
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(event.target.result, 'text/html');

                        const lessonNameElement = doc.querySelector('h1');
                        const lessonName = lessonNameElement ? lessonNameElement.textContent.trim() : `Bài học nhập từ HTML (${Date.now()})`;

                        const newVocabularies = [];
                        const vocabItems = doc.querySelectorAll('.vocab-item');

                        vocabItems.forEach(item => {
                            const hanTuElement = item.querySelector('h2 strong');
                            const pinyinElement = item.querySelector('h2 .pinyin');
                            const meaningElement = item.querySelector('p.meaning');

                            const hanTu = hanTuElement ? hanTuElement.textContent.trim() : '';
                            const pinyin = pinyinElement ? pinyinElement.textContent.replace(/[()]/g, '').trim() : '';
                            const meaning = meaningElement ? meaningElement.textContent.trim() : '';
                            const hanVietMeaning = ''; // HTML import won't have this, leave empty

                            const examples = [];
                            const exampleListItems = item.querySelectorAll('.examples ol li');
                            exampleListItems.forEach((li, idx) => {
                                if (idx < 6) {
                                    const chineseElement = li.querySelector('.chinese');
                                    const vietnameseElement = li.querySelector('.vietnamese');
                                    if (chineseElement && vietnameseElement) {
                                        examples.push({
                                            chinese: chineseElement.textContent.trim(),
                                            vietnamese: vietnameseElement.textContent.trim(),
                                            audioFileBlob: null,
                                            audioFileId: null
                                        });
                                    }
                                }
                            });

                            if (hanTu) {
                                newVocabularies.push({
                                    id: Date.now().toString() + '-' + Math.random().toString(36).substring(7),
                                    hanTu,
                                    pinyin,
                                    meaning,
                                    hanVietMeaning,
                                    notes: '',
                                    audioFile: null,
                                    examples: examples,
                                    createdAt: new Date(),
                                    wrongAttempts: 0,
                                    correctStreak: 0
                                });
                            }
                        });

                        if (newVocabularies.length === 0) {
                            setMessage({ text: "Không tìm thấy từ vựng nào trong file HTML. Vui lòng kiểm tra lại cấu trúc file.", type: "error" });
                            setIsProcessing(false);
                            if (e.target) e.target.value = '';
                            return;
                        }

                        const newLesson = {
                            id: Date.now().toString(),
                            name: lessonName,
                            createdAt: new Date(),
                            vocabularies: newVocabularies,
                            passages: []
                        };

                        setLessons(prevLessons => [...prevLessons, newLesson]);
                        setMessage({ text: `Đã nhập thành công bài học "${lessonName}" với ${newVocabularies.length} từ vựng!`, type: "success" });
                        setView('lessonList');
                        console.log("Successfully imported lesson from HTML:", newLesson);

                    } catch (parseError) {
                        console.error("Error parsing HTML file:", parseError);
                        setMessage({ text: `Lỗi khi phân tích file HTML: ${parseError.message}. Vui lòng kiểm tra định dạng file.`, type: "error" });
                    } finally {
                        setIsProcessing(false);
                        if (e.target) e.target.value = '';
                    }
                };
                reader.readAsText(file);
            };

            const calculateDaysRemaining = (dateString) => {
                if (!dateString) {
                    setDaysRemaining(null);
                    return;
                }
                const target = new Date(dateString);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                target.setHours(0, 0, 0, 0);

                const diffTime = target.getTime() - today.getTime();
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                setDaysRemaining(diffDays);
                localStorage.setItem('chineseTargetDate', dateString);
            };

            const handleTargetDateChange = (e) => {
                const dateValue = e.target.value;
                setTargetDate(dateValue);
                calculateDaysRemaining(dateValue);
            };

            const handleCheckIn = () => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                let newStreak = checkInStreak;
                let newLastCheckInDate = today;

                if (lastCheckInDate) {
                    const lastCheckIn = new Date(lastCheckInDate);
                    lastCheckIn.setHours(0, 0, 0, 0);

                    const oneDay = 24 * 60 * 60 * 1000;
                    const diffTime = today.getTime() - lastCheckIn.getTime();
                    const diffDays = Math.round(diffTime / oneDay);

                    if (diffDays === 0) {
                        setMessage({ text: "Bạn đã điểm danh hôm nay rồi!", type: "info" });
                        return;
                    } else if (diffDays === 1) {
                        newStreak++;
                    } else {
                        newStreak = 1; 
                    }
                } else {
                    newStreak = 1;
                }

                setCheckInStreak(newStreak);
                setLastCheckInDate(newLastCheckInDate);
                localStorage.setItem('chineseCheckInStreak', newStreak.toString());
                localStorage.setItem('chineseLastCheckInDate', newLastCheckInDate.toISOString());
                setMessage({ text: `Điểm danh thành công! Streak hiện tại: ${newStreak} ngày.`, type: "success" });
            };
            
            const renderMessageBox = () => {
                if (!message) return null;
                return (
                    <MessageBox
                        message={message.text}
                        type={message.type}
                        onClose={() => setMessage(null)}
                    />
                );
            };

            const renderReviewLimitModal = () => {
                if (!showReviewLimitModal.isVisible) return null;

                const { isVisible, isDifficult } = showReviewLimitModal;

                return (
                    <div className="modal-overlay">
                        <div className="modal-content">
                            <h3 className="text-xl font-bold text-gray-800 mb-4 text-center">Số câu hỏi muốn ôn tập?</h3>
                            <p className="text-gray-700 text-sm mb-4 text-center">Để trống hoặc nhập 0 để ôn tất cả từ vựng hiện có.</p>
                            <input
                                type="number"
                                value={tempReviewLimit}
                                onChange={(e) => setTempReviewLimit(e.target.value)}
                                placeholder="Tất cả"
                                min="0"
                                className="w-full border border-gray-300 rounded-md shadow-sm p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500 text-center mb-4"
                            />
                            <div className="flex justify-end space-x-3">
                                <button
                                    onClick={() => setShowReviewLimitModal({ isVisible: false, isDifficult: false })}
                                    className="bg-gray-300 text-gray-800 py-2 px-4 rounded-lg hover:bg-gray-400 transition-colors duration-200"
                                >
                                    Hủy
                                </button>
                                <button
                                    onClick={() => handleStartReviewFromModal()}
                                    className="bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors duration-200"
                                >
                                    Bắt đầu Ôn Tập
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };


            const LessonList = () => (
                <div className="container mx-auto grid gap-4">
                    {loading && <FullPageLoadingOverlay message="Đang tải dữ liệu từ bộ nhớ cục bộ..." />}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <div className="bg-blue-50 p-4 rounded-xl shadow-sm border border-blue-200 text-center">
                            <h3 className="text-lg font-bold text-blue-800 mb-2">Mục Tiêu Học Tập</h3>
                            <label htmlFor="targetDate" className="block text-sm font-medium text-gray-700 mb-1">Ngày mục tiêu:</label>
                            <input type="date" id="targetDate" value={targetDate} onChange={handleTargetDateChange}
                                className="w-full border border-gray-300 rounded-md shadow-sm p-2 text-sm focus:ring-blue-500 focus:border-blue-500 text-center" 
                                disabled={isProcessing} />
                            {daysRemaining !== null && (
                                <p className="mt-2 text-lg font-semibold text-blue-700">
                                    {daysRemaining >= 0 ? `Còn ${daysRemaining} ngày nữa đến kì thi HSK` : `Đã trôi qua ${Math.abs(daysRemaining)} ngày`}
                                </p>
                            )}
                        </div>

                        <div className="bg-purple-50 p-4 rounded-xl shadow-sm border border-purple-200 text-center">
                            <h3 className="text-lg font-bold text-purple-800 mb-2">Điểm Danh Hàng Ngày</h3>
                            <p className="text-xl font-bold text-purple-700 mb-3">Streak: {checkInStreak} ngày 🔥</p>
                            <p className="text-sm text-gray-600 mb-3">Lần điểm danh gần nhất: {lastCheckInDate ? lastCheckInDate.toLocaleDateString('vi-VN') : 'Chưa điểm danh'}</p>
                            <button onClick={handleCheckIn}
                                className={`w-full bg-purple-600 text-white py-2 px-4 rounded-lg hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                disabled={isProcessing}>
                                {isProcessing ? <LoadingSpinner /> : <i className="fas fa-check-circle mr-2"></i>} Điểm Danh Hôm Nay
                            </button>
                        </div>
                    </div>

                    <div className="flex space-x-4 mb-6">
                        <button onClick={handleExportData}
                                className={`flex-1 bg-gray-600 text-white py-3 px-4 rounded-xl hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                disabled={isProcessing}>
                            {isProcessing ? <LoadingSpinner /> : <i className="fas fa-file-export mr-2"></i>} Xuất Dữ Liệu (Backup)
                        </button>
                        <label htmlFor="import-file-input"
                               className={`flex-1 flex items-center justify-center bg-gray-400 text-white py-3 px-4 rounded-xl hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md cursor-pointer ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                               disabled={isProcessing}>
                            {isProcessing ? <LoadingSpinner /> : <i className="fas fa-file-import mr-2"></i>} Nhập Dữ Liệu (Restore)
                            <input type="file" id="import-file-input" accept="application/json" onChange={handleImportData} className="hidden" disabled={isProcessing} />
                        </label>
                        <label htmlFor="import-html-file-input"
                               className={`flex-1 flex items-center justify-center bg-blue-400 text-white py-3 px-4 rounded-xl hover:bg-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-200 shadow-md cursor-pointer ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                               disabled={isProcessing}>
                            {isProcessing ? <LoadingSpinner /> : <i className="fas fa-file-code mr-2"></i>} Nhập từ HTML
                            <input type="file" id="import-html-file-input" accept="text/html" onChange={handleImportFromHtmlFile} className="hidden" disabled={isProcessing} />
                        </label>
                    </div>

                    <h2 className="text-3xl font-bold text-primary dark:text-primary-100 mb-6 flex justify-between items-center">
                        Danh Sách Khoá Học
                        <div className="space-x-2">
                            <button onClick={() => { setCourseName(''); setView('createCourse'); }}
                                    className={`bg-primary dark:bg-primary-800 text-white text-sm py-2 px-4 rounded-full hover:bg-primary-700 dark:hover:bg-primary-900 transition-colors duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                    disabled={isProcessing}>
                                <i className="fas fa-folder-plus mr-1"></i> Tạo Khoá Học
                            </button>
                            <button onClick={() => { setLessonCourseId(courses[0]?.id || ''); setView('createLesson'); }}
                                    className={`bg-primary dark:bg-primary-800 text-white text-sm py-2 px-4 rounded-full hover:bg-primary-700 dark:hover:bg-primary-900 transition-colors duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                    disabled={isProcessing}>
                                <i className="fas fa-plus mr-1"></i> Tạo Bài Học
                            </button>
                        </div>
                    </h2>

                    <button onClick={() => promptForReviewLimit('allLessons')}
                            className={`w-full bg-green-600 text-white py-3 px-4 rounded-xl hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition-all duration-200 shadow-md mb-6 ${allVocabularies.filter(v => v.meaning || v.pinyin || (v.examples && v.examples.some(ex => ex.chinese && ex.vietnamese && splitChineseSentence(ex.chinese).length > 1))).length === 0 || isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={allVocabularies.filter(v => v.meaning || v.pinyin || (v.examples && v.examples.some(ex => ex.chinese && ex.vietnamese && splitChineseSentence(ex.chinese).length > 1))).length === 0 || isProcessing}>
                        {isProcessing ? <LoadingSpinner /> : <i className="fas fa-play mr-2"></i>}
                        Ôn Tập Tất Cả Từ Vựng
                    </button>

                    <button onClick={() => promptForReviewLimit('difficultWords', null, true)}
                            className={`w-full bg-red-600 text-white py-3 px-4 rounded-xl hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-all duration-200 shadow-md mb-6 ${allVocabularies.filter(v => v.wrongAttempts >= 2).length === 0 || isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={allVocabularies.filter(v => v.wrongAttempts >= 2).length === 0 || isProcessing}>
                        {isProcessing ? <LoadingSpinner /> : <i className="fas fa-exclamation-triangle mr-2"></i>}
                        Ôn Tập Từ Khó ({allVocabularies.filter(v => v.wrongAttempts >= 2).length})
                    </button>

                    {error ? (
                        <MessageBox message={error} type="error" />
                    ) : courses.length === 0 ? (
                        <p className="text-gray-600 text-center py-8">Chưa có khoá học nào. Hãy tạo một khoá mới!</p>
                    ) : (
                        <div className="space-y-4">
                            {courses.map((course, cIndex) => {
                                const lessonsInCourse = lessons.filter(l => l.courseId === course.id);
                                return (
                                    <div key={course.id} className="bg-gray-100 p-4 rounded-xl shadow-sm border border-gray-300">
                                        <div className="flex justify-between items-start mb-2">
                                            <div>
                                                <h3 className="text-2xl font-bold text-gray-900">{course.name}</h3>
                                            </div>
                                            <div className="flex space-x-2">
                                                <button onClick={() => handleMoveCourse(course.id, 'up')}
                                                        className={`bg-gray-400 text-white text-xs p-2 rounded-full hover:bg-gray-500 transition-colors duration-200 ${cIndex === 0 || isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                        title="Di chuyển khoá học lên"
                                                        disabled={cIndex === 0 || isProcessing}>
                                                    <i className="fas fa-arrow-up"></i>
                                                </button>
                                                <button onClick={() => handleMoveCourse(course.id, 'down')}
                                                        className={`bg-gray-400 text-white text-xs p-2 rounded-full hover:bg-gray-500 transition-colors duration-200 ${cIndex === courses.length - 1 || isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                        title="Di chuyển khoá học xuống"
                                                        disabled={cIndex === courses.length - 1 || isProcessing}>
                                                    <i className="fas fa-arrow-down"></i>
                                                </button>
                                                <button onClick={() => handleEditCourse(course)}
                                                        className={`bg-blue-500 text-white text-xs p-2 rounded-full hover:bg-blue-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                        title="Chỉnh Sửa Khoá Học"
                                                        disabled={isProcessing}>
                                                    <i className="fas fa-edit"></i>
                                                </button>
                                                <button onClick={() => toggleCourseExpand(course.id)}
                                                        className={`bg-blue-500 text-white text-xs p-2 rounded-full hover:bg-blue-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                        title="Thu gọn/Mở rộng"
                                                        disabled={isProcessing}>
                                                    <i className={`fas ${course.expanded ? 'fa-chevron-up' : 'fa-chevron-down'}`}></i>
                                                </button>
                                                <button onClick={() => handleDeleteCourse(course.id)}
                                                        className={`bg-red-500 text-white text-xs p-2 rounded-full hover:bg-red-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                        title="Xóa Khoá Học"
                                                        disabled={isProcessing}>
                                                    <i className="fas fa-trash"></i>
                                                </button>
                                            </div>
                                        </div>
                                        {course.expanded && (
                                            <div className="mt-2 space-y-4">
                                                {lessonsInCourse.length === 0 ? (
                                                    <p className="text-gray-600 text-sm">Chưa có bài học nào.</p>
                                                ) : (
                                                    lessonsInCourse.map((lesson, index) => (
                                                        <div key={lesson.id} className={`bg-gray-50 p-4 rounded-xl shadow-sm border border-gray-200 ${lesson.isTemp ? 'opacity-70 animate-pulse' : ''}`}>
                                                            <div className="flex justify-between items-start mb-2">
                                                                <div>
                                                                    <h4 className="text-xl font-bold text-gray-900">{lesson.name}</h4>
                                                                    <p className="text-gray-500 text-sm">Tạo lúc: {lesson.createdAt.toLocaleDateString('vi-VN')} | Từ vựng: {(lesson.vocabularies || []).length}</p>
                                                                </div>
                                                                <div className="flex space-x-2 items-center">
                                                                    <select value={lesson.courseId} onChange={e => handleChangeLessonCourse(lesson.id, e.target.value)}
                                                                            className="text-xs border rounded p-1">
                                                                        {courses.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                                                                    </select>
                                                                    <button onClick={() => handleMoveLesson(lesson.id, 'up')}
                                                                            className={`bg-gray-400 text-white text-xs p-2 rounded-full hover:bg-gray-500 transition-colors duration-200 ${index === 0 || isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                                            title="Di chuyển lên"
                                                                            disabled={index === 0 || isProcessing}>
                                                                        <i className="fas fa-arrow-up"></i>
                                                                    </button>
                                                                    <button onClick={() => handleMoveLesson(lesson.id, 'down')}
                                                                            className={`bg-gray-400 text-white text-xs p-2 rounded-full hover:bg-gray-500 transition-colors duration-200 ${index === lessonsInCourse.length - 1 || isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                                            title="Di chuyển xuống"
                                                                            disabled={index === lessonsInCourse.length - 1 || isProcessing}>
                                                                        <i className="fas fa-arrow-down"></i>
                                                                    </button>
                                                                    <button onClick={() => handleEditLesson(lesson)}
                                                                            className={`bg-blue-500 text-white text-xs p-2 rounded-full hover:bg-blue-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                                            title="Chỉnh Sửa Bài Học"
                                                                            disabled={isProcessing}>
                                                                        <i className="fas fa-edit"></i>
                                                                    </button>
                                                                    <button onClick={() => { setView('vocabularyList'); setSelectedLesson(lesson); }}
                                                                            className={`bg-blue-500 text-white text-xs p-2 rounded-full hover:bg-blue-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                                            title="Xem Từ Vựng"
                                                                            disabled={isProcessing}>
                                                                        <i className="fas fa-list-alt"></i>
                                                                    </button>
                                                                    <button onClick={() => { setView('passageList'); setSelectedLesson(lesson); }}
                                                                            className={`bg-purple-500 text-white text-xs p-2 rounded-full hover:bg-purple-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                                            title="Quản Lý Bài Khóa"
                                                                            disabled={isProcessing}>
                                                                        <i className="fas fa-file-alt"></i>
                                                                    </button>
                                                                    <button onClick={() => promptForReviewLimit('singleLesson', lesson)}
                                                                            className={`bg-green-500 text-white text-xs p-2 rounded-full hover:bg-green-600 transition-colors duration-200 ${
                                                                                (lessons.find(l => l.id === lesson.id)?.vocabularies?.filter(v => v.meaning || v.pinyin || (v.examples && v.examples.some(ex => ex.chinese && ex.vietnamese && splitChineseSentence(ex.chinese).length > 1)))?.length || 0) === 0 || isProcessing ? 'opacity-50 cursor-not-allowed' : ''
                                                                            }`}
                                                                            title="Ôn Tập Bài Học Này"
                                                                            disabled={(lessons.find(l => l.id === lesson.id)?.vocabularies?.filter(v => v.meaning || v.pinyin || (v.examples && v.examples.some(ex => ex.chinese && ex.vietnamese && splitChineseSentence(ex.chinese).length > 1)))?.length || 0) === 0 || isProcessing}>
                                                                        {isProcessing ? <LoadingSpinner /> : <i className="fas fa-book-open"></i>}
                                                                    </button>
                                                                    <button onClick={() => handleDeleteLesson(lesson.id)}
                                                                            className={`bg-red-500 text-white text-xs p-2 rounded-full hover:bg-red-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                                            title="Xóa Bài Học"
                                                                            disabled={isProcessing}>
                                                                        <i className="fas fa-trash"></i>
                                                                    </button>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    ))
                                                )}
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    )}
                    {renderReviewLimitModal()}
                </div>
            );

            const CreateLessonForm = () => (
                <div className="container mx-auto grid gap-4">
                <form onSubmit={handleCreateLessonSubmit} className="space-y-4 relative">
                    {isProcessing && <div className="form-overlay"><LoadingSpinner /><p className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center text-lg font-semibold text-gray-700 mt-16">Đang tạo...</p></div>}
                    <h2 className="text-3xl font-bold text-gray-800 mb-6">Tạo Bài Học Mới</h2>
                    <div>
                        <label htmlFor="lessonName" className="block text-sm font-medium text-gray-700">Tên Bài Học:</label>
                        <input type="text" id="lessonName" value={lessonName} onChange={(e) => setLessonName(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>
                    <div>
                        <label htmlFor="lessonCourse" className="block text-sm font-medium text-gray-700">Khoá Học:</label>
                        <select id="lessonCourse" value={lessonCourseId} onChange={e => setLessonCourseId(e.target.value)}
                                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                                disabled={isProcessing}>
                            {courses.map(course => <option key={course.id} value={course.id}>{course.name}</option>)}
                        </select>
                    </div>
                    <button type="submit"
                            className={`w-full bg-indigo-600 text-white py-3 px-4 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isProcessing}>
                        {isProcessing ? <LoadingSpinner /> : <i className="fas fa-plus mr-2"></i>} Tạo Bài Học
                    </button>
                    <button type="button" onClick={() => setView('lessonList')}
                            className="w-full mt-2 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md"
                            disabled={isProcessing}>
                        <i className="fas fa-arrow-left mr-2"></i> Quay Lại Danh Sách Bài Học
                    </button>
                </form>
                </div>
            );

            const renderEditLessonForm = () => (
                <form onSubmit={handleUpdateLessonSubmit} className="space-y-4 relative">
                    {isProcessing && <div className="form-overlay"><LoadingSpinner /><p className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center text-lg font-semibold text-gray-700 mt-16">Đang lưu...</p></div>}
                    <h2 className="text-3xl font-bold text-gray-800 mb-6">Chỉnh Sửa Tên Bài Học: <span className="text-indigo-600">{editingLesson?.name}</span></h2>
                    <div>
                        <label htmlFor="lessonName" className="block text-sm font-medium text-gray-700">Tên Bài Học Mới:</label>
                        <input type="text" id="lessonName" value={lessonName} onChange={(e) => setLessonName(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>
                    <div>
                        <label htmlFor="lessonCourseEdit" className="block text-sm font-medium text-gray-700">Khoá Học:</label>
                        <select id="lessonCourseEdit" value={lessonCourseId} onChange={e => setLessonCourseId(e.target.value)}
                                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                                disabled={isProcessing}>
                            {courses.map(course => <option key={course.id} value={course.id}>{course.name}</option>)}
                        </select>
                    </div>
                    <button type="submit"
                            className={`w-full bg-indigo-600 text-white py-3 px-4 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isProcessing}>
                        {isProcessing ? <LoadingSpinner /> : <i className="fas fa-save mr-2"></i>} Lưu Chỉnh Sửa
                    </button>
                    <button type="button" onClick={() => { setView('lessonList'); setLessonName(''); setEditingLesson(null); }}
                            className="w-full mt-2 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md"
                            disabled={isProcessing}>
                        <i className="fas fa-times mr-2"></i> Hủy
                    </button>
                </form>
            );

            const renderCreateCourseForm = () => (
                <form onSubmit={handleCreateCourseSubmit} className="space-y-4 relative">
                    {isProcessing && <div className="form-overlay"><LoadingSpinner /><p className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center text-lg font-semibold text-gray-700 mt-16">Đang tạo...</p></div>}
                    <h2 className="text-3xl font-bold text-gray-800 mb-6">Tạo Khoá Học Mới</h2>
                    <div>
                        <label htmlFor="courseName" className="block text-sm font-medium text-gray-700">Tên Khoá Học:</label>
                        <input type="text" id="courseName" value={courseName} onChange={e => setCourseName(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>
                    <button type="submit"
                            className={`w-full bg-indigo-600 text-white py-3 px-4 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isProcessing}>
                        {isProcessing ? <LoadingSpinner /> : <i className="fas fa-plus mr-2"></i>} Tạo Khoá Học
                    </button>
                    <button type="button" onClick={() => setView('lessonList')}
                            className="w-full mt-2 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md"
                            disabled={isProcessing}>
                        <i className="fas fa-arrow-left mr-2"></i> Quay Lại
                    </button>
                </form>
            );

            const renderEditCourseForm = () => (
                <form onSubmit={handleUpdateCourseSubmit} className="space-y-4 relative">
                    {isProcessing && <div className="form-overlay"><LoadingSpinner /><p className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center text-lg font-semibold text-gray-700 mt-16">Đang lưu...</p></div>}
                    <h2 className="text-3xl font-bold text-gray-800 mb-6">Chỉnh Sửa Khoá Học: <span className="text-indigo-600">{editingCourse?.name}</span></h2>
                    <div>
                        <label htmlFor="courseNameEdit" className="block text-sm font-medium text-gray-700">Tên Khoá Học Mới:</label>
                        <input type="text" id="courseNameEdit" value={courseName} onChange={e => setCourseName(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>
                    <button type="submit"
                            className={`w-full bg-indigo-600 text-white py-3 px-4 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isProcessing}>
                        {isProcessing ? <LoadingSpinner /> : <i className="fas fa-save mr-2"></i>} Lưu Khoá Học
                    </button>
                    <button type="button" onClick={() => { setView('lessonList'); setCourseName(''); setEditingCourse(null); }}
                            className="w-full mt-2 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md"
                            disabled={isProcessing}>
                        <i className="fas fa-times mr-2"></i> Hủy
                    </button>
                </form>
            );

            const renderVocabularyList = () => (
                <>
                    <h2 className="text-3xl font-bold text-gray-800 mb-6 flex justify-between items-center">
                        Từ Vựng của Bài Học: <span className="text-indigo-600">{selectedLesson?.name}</span>
                        <button onClick={() => setView('createVocabulary')}
                                className={`bg-indigo-500 text-white text-sm py-2 px-4 rounded-full hover:bg-indigo-600 transition-colors duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                disabled={isProcessing}>
                            <i className="fas fa-plus mr-1"></i> Thêm Từ Vựng
                        </button>
                    </h2>
                    <button onClick={() => promptForReviewLimit('singleLesson', selectedLesson)}
                            className={`w-full bg-green-600 text-white py-3 px-4 rounded-xl hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition-all duration-200 shadow-md mb-6 ${vocabularies.filter(v => v.meaning || v.pinyin || (v.examples && v.examples.some(ex => ex.chinese && ex.vietnamese && splitChineseSentence(ex.chinese).length > 1))).length === 0 || isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={vocabularies.filter(v => v.meaning || v.pinyin || (v.examples && v.examples.some(ex => ex.chinese && ex.vietnamese && splitChineseSentence(ex.chinese).length > 1))).length === 0 || isProcessing}>
                        {isProcessing ? <LoadingSpinner /> : <i className="fas fa-play mr-2"></i>}
                        Ôn Tập Từ Vựng Bài Này
                    </button>

                    {error ? (
                        <MessageBox message={error} type="error" />
                    ) : vocabularies.length === 0 ? (
                        <p className="text-gray-600 text-center py-8">Chưa có từ vựng nào trong bài học này. Hãy thêm một từ mới!</p>
                    ) : (
                        <div className="space-y-4">
                            {vocabularies.map((vocab) => (
                                <div key={vocab.id} className={`bg-gray-50 p-4 rounded-xl shadow-sm border border-gray-200 ${vocab.isTemp ? 'opacity-70 animate-pulse' : ''}`}>
                                    <div className="flex justify-between items-start mb-2">
                                        <div>
                                            <div className="flex items-center space-x-2">
                                                <h3 className="text-xl font-bold text-gray-900">{vocab.hanTu}</h3>
                                                {vocab.hanTu && (
                                                    <button onClick={() => handlePlayDetailAudio(vocab.audioFile, vocab.hanTu)}
                                                            className="text-indigo-600 hover:text-indigo-800 text-lg focus:outline-none"
                                                            disabled={isProcessing}>
                                                        <i className="fas fa-volume-up"></i>
                                                    </button>
                                                )}
                                            </div>
                                            <p className="text-indigo-600 text-base">{vocab.pinyin}</p>
                                        </div>
                                        <div className="flex space-x-2">
                                            <button onClick={() => handleEditVocabulary(vocab)}
                                                    className={`bg-blue-500 text-white text-xs p-2 rounded-full hover:bg-blue-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                    title="Chỉnh Sửa Từ Vựng"
                                                    disabled={isProcessing}>
                                                <i className="fas fa-edit"></i>
                                            </button>
                                            <button onClick={() => handleDeleteVocabulary(vocab.id)}
                                                    className={`bg-red-500 text-white text-xs p-2 rounded-full hover:bg-red-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                    title="Xóa Từ Vựng"
                                                    disabled={isProcessing}>
                                                <i className="fas fa-trash"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <p className="text-gray-700 mt-2">
                                        Nghĩa: {vocab.hanVietMeaning && <span className="text-gray-500">[{vocab.hanVietMeaning}] </span>}
                                        <span className="font-medium">{vocab.meaning}</span>
                                    </p>
                                    {vocab.notes && <p className="text-gray-600 text-sm mt-1">Ghi chú: {vocab.notes}</p>}
                                    {vocab.examples && vocab.examples.length > 0 && (
                                        <div className="mt-3 text-sm text-gray-700">
                                            <p className="font-semibold mb-1">Ví dụ:</p>
                                            <ul className="list-none space-y-1">
                                                {vocab.examples.map((ex, idx) => ex.chinese && ex.vietnamese && (
                                                    <li key={idx} className="flex items-start">
                                                        {ex.chinese && (
                                                            <button onClick={() => handlePlayDetailAudio(ex.audioFile, ex.chinese)}
                                                                    className="text-indigo-600 text-sm mr-2 focus:outline-none"
                                                                    disabled={isProcessing}>
                                                                <i className="fas fa-volume-up"></i>
                                                            </button>
                                                        )}
                                                        <span>{ex.chinese} <span className="text-gray-500">- {ex.vietnamese}</span></span>
                                                    </li>
                                                ))}
                                            </ul>
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                    )}
                    <button type="button" onClick={() => { setView('lessonList'); setSelectedLesson(null); }}
                            className={`w-full mt-8 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isProcessing}>
                        <i className="fas fa-arrow-left mr-2"></i> Quay Lại Danh Sách Bài Học
                    </button>
                    {renderReviewLimitModal()}
                </>
            );

            const renderCreateVocabularyForm = () => (
                <form onSubmit={handleCreateVocabularySubmit} className="space-y-4 relative">
                    {isProcessing && <div className="form-overlay"><LoadingSpinner /><p className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center text-lg font-semibold text-gray-700 mt-16">Đang thêm từ vựng...</p></div>}
                    <h2 className="text-3xl font-bold text-gray-800 mb-6">Thêm Từ Vựng vào Bài: <span className="text-indigo-600">{selectedLesson?.name}</span></h2>
                    <div>
                        <label htmlFor="hanTu" className="block text-sm font-medium text-gray-700">Hán tự:</label>
                        <input type="text" id="hanTu" value={hanTu} onChange={(e) => setHanTu(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>
                    <div>
                        <label htmlFor="pinyin" className="block text-sm font-medium text-gray-700">Bính âm:</label>
                        <input type="text" id="pinyin" value={pinyin} onChange={(e) => setPinyin(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>
                    <div>
                        <label htmlFor="meaning" className="block text-sm font-medium text-gray-700">Nghĩa tiếng Việt:</label>
                        <input type="text" id="meaning" value={meaning} onChange={(e) => setMeaning(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>
                    <div>
                        <label htmlFor="hanVietMeaning" className="block text-sm font-medium text-gray-700">Nghĩa Hán Việt:</label>
                        <input type="text" id="hanVietMeaning" value={hanVietMeaning} onChange={(e) => setHanVietMeaning(e.target.value)}
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               placeholder="Ví dụ: Hán Việt"
                               disabled={isProcessing} />
                    </div>
                    <div>
                        <label htmlFor="vocabAudio" className="block text-sm font-medium text-gray-700">File âm thanh từ vựng (MP3):</label>
                        <input type="file" id="vocabAudio" accept="audio/mpeg" onChange={(e) => handleAudioFileChange(e, false)}
                               className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
                               disabled={isProcessing} />
                        {(audioFileBlob || currentAudioFileId) && (
                            <div className="flex items-center space-x-2 mt-2 text-sm text-gray-600">
                                <span>{audioFileBlob ? audioFileBlob.name : 'File đã chọn'}</span>
                                <button type="button" onClick={() => handleRemoveAudio(false)} className="text-red-500 hover:text-red-700"
                                        disabled={isProcessing}>
                                    <i className="fas fa-times-circle"></i>
                                </button>
                            </div>
                        )}
                    </div>
                    <div>
                        <label htmlFor="notes" className="block text-sm font-medium text-gray-700">Ghi chú:</label>
                        <textarea id="notes" value={notes} onChange={(e) => setNotes(e.target.value)}
                                  rows="3" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                                  disabled={isProcessing}></textarea>
                    </div>

                    <h3 className="text-xl font-semibold text-gray-700 mt-6 mb-4">6 Câu Ví Dụ:</h3>
                    {examples.map((example, index) => (
                        <div key={index} className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium text-gray-700">Ví dụ {index + 1} (Tiếng Trung):</label>
                                <input type="text" value={example.chinese} onChange={(e) => handleExampleChange(index, 'chinese', e.target.value)}
                                       className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
                                       disabled={isProcessing} />
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-700">Nghĩa ví dụ {index + 1} (Tiếng Việt):</label>
                                <input type="text" value={example.vietnamese} onChange={(e) => handleExampleChange(index, 'vietnamese', e.target.value)}
                                       className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
                                       disabled={isProcessing} />
                            </div>
                            <div className="col-span-2">
                                <label className="block text-sm font-medium text-gray-700">File âm thanh ví dụ {index + 1} (MP3):</label>
                                <input type="file" id={`exampleAudio-${index}`} accept="audio/mpeg" onChange={(e) => handleAudioFileChange(e, true, index)}
                                       className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
                                       disabled={isProcessing} />
                                {(example.audioFileBlob || example.audioFileId) && (
                                    <div className="flex items-center space-x-2 mt-2 text-sm text-gray-600">
                                        <span>{example.audioFileBlob ? example.audioFileBlob.name : 'File đã chọn'}</span>
                                        <button type="button" onClick={() => handleRemoveAudio(true, index)} className="text-red-500 hover:text-red-700"
                                                disabled={isProcessing}>
                                            <i className="fas fa-times-circle"></i>
                                        </button>
                                    </div>
                                )}
                            </div>
                        </div>
                    ))}

                    <button type="submit"
                            className={`w-full bg-indigo-600 text-white py-3 px-4 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isProcessing}>
                        {isProcessing ? <LoadingSpinner /> : <i className="fas fa-plus mr-2"></i>} Thêm Từ Vựng
                    </button>
                    <button type="button" onClick={() => setView('vocabularyList')}
                            className="w-full mt-2 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md"
                            disabled={isProcessing}>
                        <i className="fas fa-arrow-left mr-2"></i> Quay Lại Danh Sách Từ Vựng
                    </button>
                </form>
            );

            
            const renderEditVocabularyForm = () => (
                <form onSubmit={handleUpdateVocabularySubmit} className="space-y-4 relative">
                    {isProcessing && <div className="form-overlay"><LoadingSpinner /><p className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center text-lg font-semibold text-gray-700 mt-16">Đang lưu chỉnh sửa...</p></div>}
                    <h2 className="text-3xl font-bold text-gray-800 mb-6">Chỉnh Sửa Từ Vựng: <span className="text-indigo-600">{editingVocab?.hanTu}</span></h2>
                    <div>
                        <label htmlFor="hanTu" className="block text-sm font-medium text-gray-700">Hán tự:</label>
                        <input type="text" id="hanTu" value={hanTu} onChange={(e) => setHanTu(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>
                    <div>
                        <label htmlFor="pinyin" className="block text-sm font-medium text-gray-700">Bính âm:</label>
                        <input type="text" id="pinyin" value={pinyin} onChange={(e) => setPinyin(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>
                    <div>
                        <label htmlFor="meaning" className="block text-sm font-medium text-gray-700">Nghĩa tiếng Việt:</label>
                        <input type="text" id="meaning" value={meaning} onChange={(e) => setMeaning(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>
                    <div>
                        <label htmlFor="hanVietMeaning" className="block text-sm font-medium text-gray-700">Nghĩa Hán Việt:</label>
                        <input type="text" id="hanVietMeaning" value={hanVietMeaning} onChange={(e) => setHanVietMeaning(e.target.value)}
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               placeholder="Ví dụ: Hán Việt"
                               disabled={isProcessing} />
                    </div>
                    <div>
                        <label htmlFor="vocabAudio" className="block text-sm font-medium text-gray-700">File âm thanh từ vựng (MP3):</label>
                        <input type="file" id="vocabAudio" accept="audio/mpeg" onChange={(e) => handleAudioFileChange(e, false)}
                               className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
                               disabled={isProcessing} />
                        {(audioFileBlob || currentAudioFileId) && (
                            <div className="flex items-center space-x-2 mt-2 text-sm text-gray-600">
                                <span>{audioFileBlob ? audioFileBlob.name : 'File đã chọn'}</span>
                                <button type="button" onClick={() => handleRemoveAudio(false)} className="text-red-500 hover:text-red-700"
                                        disabled={isProcessing}>
                                    <i className="fas fa-times-circle"></i>
                                </button>
                            </div>
                        )}
                    </div>
                    <div>
                        <label htmlFor="notes" className="block text-sm font-medium text-gray-700">Ghi chú:</label>
                        <textarea id="notes" value={notes} onChange={(e) => setNotes(e.target.value)}
                                  rows="3" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                                  disabled={isProcessing}></textarea>
                    </div>

                    <h3 className="text-xl font-semibold text-gray-700 mt-6 mb-4">6 Câu Ví Dụ:</h3>
                    {examples.map((example, index) => (
                        <div key={index} className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium text-gray-700">Ví dụ {index + 1} (Tiếng Trung):</label>
                                <input type="text" value={example.chinese} onChange={(e) => handleExampleChange(index, 'chinese', e.target.value)}
                                       className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
                                       disabled={isProcessing} />
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-700">Nghĩa ví dụ {index + 1} (Tiếng Việt):</label>
                                <input type="text" value={example.vietnamese} onChange={(e) => handleExampleChange(index, 'vietnamese', e.target.value)}
                                       className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
                                       disabled={isProcessing} />
                            </div>
                            <div className="col-span-2">
                                <label className="block text-sm font-medium text-gray-700">File âm thanh ví dụ {index + 1} (MP3):</label>
                                <input type="file" id={`exampleAudio-${index}`} accept="audio/mpeg" onChange={(e) => handleAudioFileChange(e, true, index)}
                                       className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
                                       disabled={isProcessing} />
                                {(example.audioFileBlob || example.audioFileId) && (
                                    <div className="flex items-center space-x-2 mt-2 text-sm text-gray-600">
                                        <span>{example.audioFileBlob ? example.audioFileBlob.name : 'File đã chọn'}</span>
                                        <button type="button" onClick={() => handleRemoveAudio(true, index)} className="text-red-500 hover:text-red-700"
                                                disabled={isProcessing}>
                                            <i className="fas fa-times-circle"></i>
                                        </button>
                                    </div>
                                )}
                            </div>
                        </div>
                    ))}

                    <button type="submit"
                            className={`w-full bg-indigo-600 text-white py-3 px-4 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isProcessing}>
                        {isProcessing ? <LoadingSpinner /> : <i className="fas fa-plus mr-2"></i>} Thêm Từ Vựng
                    </button>
                    <button type="button" onClick={() => setView('vocabularyList')}
                            className="w-full mt-2 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md"
                            disabled={isProcessing}>
                        <i className="fas fa-arrow-left mr-2"></i> Quay Lại Danh Sách Từ Vựng
                    </button>
                </form>
            );

            // NEW: Passage Audio Handler - tương tự handleAudioFileChange, nhưng cho passage sentences
            const handlePassageSentenceAudioChange = (e, index) => {
                const file = e.target.files[0];
                if (!file) {
                    e.target.value = '';
                    return;
                }

                if (!file.type.startsWith('audio/')) {
                    setMessage({ text: "Vui lòng chọn một file âm thanh (MP3).", type: "error" });
                    e.target.value = '';
                    return;
                }

                setPassageSentences(prevSentences =>
                    prevSentences.map((s, i) =>
                        i === index ? { ...s, audioFileBlob: file, audioFileId: null } : s
                    )
                );
                console.log(`Audio file selected for passage sentence ${index}:`, file.name);
            };

            // NEW: Remove Passage Sentence Audio
            const handleRemovePassageSentenceAudio = async (index) => {
                const audioIdToDelete = passageSentences[index].audioFileId;
                setPassageSentences(prevSentences => {
                    const newSentences = prevSentences.map((s, i) =>
                        i === index ? { ...s, audioFileBlob: null, audioFileId: null } : s
                    );
                    const fileInput = document.getElementById(`passageAudio-${index}`);
                    if (fileInput) {
                        fileInput.value = '';
                    }
                    return newSentences;
                });
                if (audioIdToDelete) {
                    await deleteAudioFile(audioIdToDelete);
                    console.log("Removed passage sentence audio from IndexedDB:", audioIdToDelete);
                }
                console.log(`Audio removed for passage sentence ${index}.`);
            };

            // NEW: Handle passage sentence changes
            const handlePassageSentenceChange = (index, field, value) => {
                setPassageSentences(prevSentences =>
                    prevSentences.map((s, i) =>
                        i === index ? { ...s, [field]: value } : s
                    )
                );
            };

            // NEW: Add new empty sentence row
            const handleAddPassageSentence = (speaker = '') => {
                setPassageSentences(prev => [...prev, { chinese: '', pinyin: '', vietnamese: '', audioFileBlob: null, audioFileId: null, speaker: speaker }]);
            };

            // NEW: Remove sentence row
            const handleRemovePassageSentence = async (index) => {
                if (passageSentences.length <= 1) {
                    setMessage({ text: "Bài khóa phải có ít nhất một câu.", type: "error" });
                    return;
                }
                if (window.confirm("Bạn có chắc muốn xóa câu này khỏi bài khóa không?")) {
                    const sentenceToRemove = passageSentences[index];
                    if (sentenceToRemove.audioFileId) {
                        await deleteAudioFile(sentenceToRemove.audioFileId);
                    }
                    setPassageSentences(prev => prev.filter((_, i) => i !== index));
                    setMessage({ text: "Câu đã được xóa khỏi bài khóa.", type: "success" });
                }
            };


            // NEW: Handle Create Passage Submit
            const handleCreatePassageSubmit = async (e) => {
                e.preventDefault();
                if (!selectedLesson || isProcessing) {
                    setMessage({ text: "Chưa chọn bài học hoặc đang xử lý. Vui lòng đợi.", type: "error" });
                    return;
                }
                if (!passageTitle.trim()) {
                    setMessage({ text: "Tiêu đề bài khóa không được để trống.", type: "error" });
                    return;
                }
                const filteredSentences = passageSentences.filter(s => s.chinese.trim());
                if (filteredSentences.length === 0) {
                    setMessage({ text: "Bài khóa phải có ít nhất một câu Hán tự.", type: "error" });
                    return;
                }

                setIsProcessing(true);
                console.log("Starting passage creation process...");

                const processedSentencesPromises = passageSentences.map(async (s) => {
                    if (!s.chinese.trim()) return null;

                    let sentenceAudioId = null;
                    if (s.audioFileBlob instanceof File) { 
                        try {
                            sentenceAudioId = await processAndStoreAudio(s.audioFileBlob, s.audioFileId);
                        } catch (e) {
                            setMessage({ text: `Lỗi lưu file âm thanh cho câu "${s.chinese}": ${e.message}`, type: "error" });
                            console.error(`Error storing passage sentence audio:`, e);
                            throw e; 
                        }
                    } else if (s.audioFileId) { 
                        sentenceAudioId = s.audioFileId;
                    }
                    return { chinese: s.chinese, pinyin: s.pinyin, vietnamese: s.vietnamese, audioFile: sentenceAudioId, speaker: s.speaker };
                });

                let processedSentences;
                try {
                    processedSentences = (await Promise.all(processedSentencesPromises)).filter(s => s !== null);
                } catch (e) {
                    setIsProcessing(false);
                    return;
                }

                const newPassage = {
                    id: Date.now().toString(),
                    title: passageTitle,
                    sentences: processedSentences,
                    createdAt: new Date(),
                };

                setLessons(prevLessons =>
                    prevLessons.map(lesson =>
                        lesson.id === selectedLesson.id
                            ? { ...lesson, passages: [...(lesson.passages || []), newPassage] }
                            : lesson
                    )
                );
                setMessage({ text: "Bài khóa đã được thêm vào bài học!", type: "success" });
                setPassageTitle('');
                setPassageSentences([{ chinese: '', pinyin: '', vietnamese: '', audioFileBlob: null, audioFileId: null, speaker: '' }]);
                setView('passageList');
                setIsProcessing(false);
                console.log("Passage successfully created and added locally:", newPassage);
            };

            // NEW: Handle Edit Passage
            const handleEditPassage = (passage) => {
                console.log("Entering edit passage mode for:", passage);
                setEditingPassage(passage);
                setPassageTitle(passage.title);
                const hydratedSentences = passage.sentences.map(s => ({
                    chinese: s.chinese,
                    pinyin: s.pinyin,
                    vietnamese: s.vietnamese,
                    audioFileBlob: null, 
                    audioFileId: s.audioFile, 
                    speaker: s.speaker || '' 
                }));
                setPassageSentences(hydratedSentences.length > 0 ? hydratedSentences : [{ chinese: '', pinyin: '', vietnamese: '', audioFileBlob: null, audioFileId: null, speaker: '' }]);
                setView('editPassage');
                passage.sentences.forEach((s, i) => {
                    const fileInput = document.getElementById(`passageAudio-${i}`);
                    if(fileInput) fileInput.value = '';
                });
            };

            // NEW: Handle Update Passage Submit
            const handleUpdatePassageSubmit = async (e) => {
                e.preventDefault();
                if (!editingPassage || !selectedLesson || isProcessing) {
                    setMessage({ text: "Chưa chọn bài học hoặc bài khóa để chỉnh sửa, hoặc đang xử lý. Vui lòng đợi.", type: "error" });
                    return;
                }
                if (!passageTitle.trim()) {
                    setMessage({ text: "Tiêu đề bài khóa không được để trống.", type: "error" });
                    return;
                }
                const filteredSentences = passageSentences.filter(s => s.chinese.trim());
                if (filteredSentences.length === 0) {
                    setMessage({ text: "Bài khóa phải có ít nhất một câu Hán tự.", type: "error" });
                    return;
                }

                setIsProcessing(true);
                console.log("Starting passage update process for:", editingPassage.id);

                const processedSentencesPromises = passageSentences.map(async (s, index) => {
                    if (!s.chinese.trim()) { 
                        const oldSentenceAudioId = editingPassage.sentences?.[index]?.audioFile || null;
                        if (oldSentenceAudioId) {
                            await deleteAudioFile(oldSentenceAudioId);
                            console.log("Deleted old sentence audio because sentence is now empty:", oldSentenceAudioId);
                        }
                        return null;
                    }

                    const oldSentenceAudioId = editingPassage.sentences?.[index]?.audioFile || null; 
                    let sentenceAudioId = null;
                    if (s.audioFileBlob instanceof File) { 
                        try {
                            sentenceAudioId = await processAndStoreAudio(s.audioFileBlob, oldSentenceAudioId);
                        } catch (e) {
                            setMessage({ text: `Lỗi xử lý file âm thanh cho câu "${s.chinese}": ${e.message}`, type: "error" });
                            console.error(`Error during passage sentence audio update:`, e);
                            throw e;
                        }
                    } else if (s.audioFileId) { 
                        sentenceAudioId = s.audioFileId;
                    } else if (oldSentenceAudioId) { 
                         sentenceAudioId = oldSentenceAudioId;
                    }

                    return { chinese: s.chinese, pinyin: s.pinyin, vietnamese: s.vietnamese, audioFile: sentenceAudioId, speaker: s.speaker };
                });

                let processedSentences;
                try {
                    processedSentences = (await Promise.all(processedSentencesPromises)).filter(s => s !== null);
                } catch (e) {
                    setIsProcessing(false);
                    return;
                }

                const updatedPassage = {
                    ...editingPassage,
                    title: passageTitle,
                    sentences: processedSentences,
                    updatedAt: new Date(),
                };

                setLessons(prevLessons =>
                    prevLessons.map(lesson =>
                        lesson.id === selectedLesson.id
                            ? {
                                ...lesson,
                                passages: (lesson.passages || []).map(p =>
                                    p.id === updatedPassage.id ? updatedPassage : p
                                )
                            }
                            : lesson
                    )
                );
                setMessage({ text: "Bài khóa đã được cập nhật thành công!", type: "success" });
                setPassageTitle('');
                setPassageSentences([{ chinese: '', pinyin: '', vietnamese: '', audioFileBlob: null, audioFileId: null, speaker: '' }]);
                setEditingPassage(null);
                setView('passageList');
                setIsProcessing(false);
                console.log("Passage successfully updated locally:", updatedPassage);
            };


            const handleDeletePassage = async (passageId) => {
                if (window.confirm("Bạn có chắc muốn xóa bài khóa này và TẤT CẢ âm thanh đính kèm không?")) {
                    setIsProcessing(true);
                    console.log("Starting passage deletion process for:", passageId);
                    const lessonIndex = lessons.findIndex(l => l.id === selectedLesson.id);
                    if (lessonIndex === -1) { setIsProcessing(false); return; }

                    const passageToDelete = lessons[lessonIndex].passages.find(p => p.id === passageId);
                    if (passageToDelete && passageToDelete.sentences) {
                        for (const sentence of passageToDelete.sentences) {
                            if (sentence.audioFile) {
                                await deleteAudioFile(sentence.audioFile);
                                console.log("Deleted associated sentence audio from IndexedDB:", sentence.audioFile);
                            }
                        }
                    }

                    setLessons(prevLessons =>
                        prevLessons.map(lesson =>
                            lesson.id === selectedLesson.id
                                ? { ...lesson, passages: (lesson.passages || []).filter(p => p.id !== passageId) }
                                : lesson
                        )
                    );
                    setMessage({ text: "Bài khóa đã được xóa thành công!", type: "success" });
                    setIsProcessing(false);
                    console.log("Passage deleted locally:", passageId);
                }
            };


            // NEW: Start Passage Study
            const startPassageStudy = (passage) => {
                setSelectedPassage(passage);
                setPassageMode('reading');
                setCurrentSentenceIndex(0);
                setSentenceInput('');
                setPopupWord(null);
                setMessage(null);
                setShowPassagePinyin(false);
                setShowPassageMeaning(true);
                stopSpeaking();
                stopPlayingAllPassage();
                setView('passageStudy');
                console.log("Starting study for passage:", passage.title);
            };

            // NEW: Play Passage Sentence Audio (now uses speakText)
            const speakSentence = async (sentence) => {
                if (!sentence || !sentence.chinese) return;
                speakText(sentence.chinese, sentence.audioFile, passagePlaybackRate);
            };
            
            // NEW: Function to play entire passage sequentially (now uses speakText)
            const playFullPassage = async (startIndex = 0) => {
                if (!selectedPassage || !selectedPassage.sentences.length) return;

                stopSpeaking();
                isPlayingAllPassage.current = true;
                currentPassageAudioIndex.current = startIndex;

                const playNextSentenceInPassage = () => {
                    if (!isPlayingAllPassage.current || currentPassageAudioIndex.current >= selectedPassage.sentences.length) {
                        isPlayingAllPassage.current = false;
                        currentPassageAudioIndex.current = 0;
                        setMessage({ text: "Đã hoàn thành phát toàn bộ bài khóa.", type: "info" });
                        return;
                    }

                    const sentence = selectedPassage.sentences[currentPassageAudioIndex.current];
                    
                    speakText(sentence.chinese, sentence.audioFile, passagePlaybackRate, () => {
                        currentPassageAudioIndex.current++;
                        playNextSentenceInPassage();
                    });
                };

                playNextSentenceInPassage();
            };

            // NEW: Stop playing full passage
            const stopPlayingAllPassage = () => {
                isPlayingAllPassage.current = false;
                stopSpeaking();
                console.log("Stopped full passage playback.");
            };


            // NEW: Handle click for word pop-up (Reading Mode) - ADVANCED MATCHING
            const handleWordClickInPassage = (event, sentenceText) => {
                stopSpeaking();
                setPopupWord(null);
                if (popupRef.current) popupRef.current.style.display = 'none';

                const clickedElement = event.target;
                if (!clickedElement.classList.contains('hanzi-char-span')) return;

                const textContentBefore = Array.from(clickedElement.parentNode.childNodes)
                                            .slice(0, Array.from(clickedElement.parentNode.childNodes).indexOf(clickedElement))
                                            .map(node => node.textContent)
                                            .join('');
                const clickedCharIndexInSentence = textContentBefore.length;

                let bestMatch = null;
                const MAX_WORD_LEN = 4; 

                for (let len = MAX_WORD_LEN; len >= 1; len--) {
                    for (let startOffset = 0; startOffset < len; startOffset++) {
                        const wordStart = clickedCharIndexInSentence - startOffset;
                        if (wordStart < 0) continue; 

                        const wordEnd = wordStart + len;
                        if (wordEnd > sentenceText.length) continue; 

                        const potentialWordHanTu = sentenceText.substring(wordStart, wordEnd);
                        if (!potentialWordHanTu.match(/^[\u4e00-\u9fff\u3400-\u4DBF]+$/)) continue; 

                        const foundVocab = allVocabularies.find(vocab => 
                            normalizeHanTu(vocab.hanTu) === normalizeHanTu(potentialWordHanTu)
                        );

                        if (foundVocab) {
                            bestMatch = foundVocab;
                            break;
                        }
                    }
                    if (bestMatch) break;
                }


                if (bestMatch) {
                    setPopupWord(bestMatch);
                    console.log("Found best match for popup:", bestMatch);
                    if (popupRef.current) {
                        const { clientX, clientY } = event;
                        const popupWidth = 300; 
                        const popupHeight = 250; 

                        const mainContent = document.querySelector('.max-w-screen-lg');
                        const mainContentRect = mainContent ? mainContent.getBoundingClientRect() : { left: 0, top: 0, right: window.innerWidth, bottom: window.innerHeight };

                        let left = clientX + 10;
                        let top = clientY + 10;

                        if (left + popupWidth > mainContentRect.right) {
                            left = clientX - popupWidth - 10;
                            if (left < mainContentRect.left) {
                                left = mainContentRect.right - popupWidth - 10;
                            }
                        }
                        if (top + popupHeight > mainContentRect.bottom) {
                            top = clientY - popupHeight - 10;
                            if (top < mainContentRect.top) {
                                top = mainContentRect.bottom - popupHeight - 10;
                            }
                        }
                        if (left < mainContentRect.left) left = mainContentRect.left + 10;
                        if (top < mainContentRect.top) top = mainContentRect.top + 10;
                        
                        popupRef.current.style.left = `${left}px`;
                        popupRef.current.style.top = `${top}px`;
                        popupRef.current.style.display = 'block';
                    }
                } else {
                    setPopupWord(null);
                    if (popupRef.current) {
                        popupRef.current.style.display = 'none';
                    }
                }
            };

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (popupRef.current && !popupRef.current.contains(event.target)) {
                        let isHanziSpanOrPassageText = false;
                        let targetElement = event.target;
                        while(targetElement && targetElement !== document.body) {
                            if (targetElement.classList.contains('hanzi-char-span') || targetElement.classList.contains('passage-sentence-text')) {
                                isHanziSpanOrPassageText = true; 
                                break;
                            }
                            targetElement = targetElement.parentElement;
                        }

                        if (!isHanziSpanOrPassageText) { 
                            setPopupWord(null);
                            if (popupRef.current) {
                                popupRef.current.style.display = 'none';
                            }
                        }
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => {
                    document.removeEventListener('mousedown', handleClickOutside);
                };
            }, []); 


            const setupFillInBlanks = () => {
                if (!selectedPassage || !selectedPassage.sentences || selectedPassage.sentences.length === 0) return;

                const sentence = selectedPassage.sentences[currentSentenceIndex];
                const hanTuChars = sentence.chinese.split(''); 
                
                const eligibleIndices = hanTuChars
                                        .map((char, idx) => ({ char, idx }))
                                        .filter(item => item.char.match(/[\u4e00-\u9fff\u3400-\u4DBF]/)); 
                
                const maxMissingCount = Math.min(eligibleIndices.length, 3); 
                const missingCount = Math.min(Math.max(1, Math.floor(eligibleIndices.length * 0.25)), maxMissingCount); 
                
                const indicesToMiss = new Set();
                const tempEligibleIndices = [...eligibleIndices];
                while (indicesToMiss.size < missingCount && tempEligibleIndices.length > 0) {
                    const randomIndexInEligible = Math.floor(Math.random() * tempEligibleIndices.length);
                    indicesToMiss.add(tempEligibleIndices[randomIndexInEligible].idx);
                    tempEligibleIndices.splice(randomIndexInEligible, 1);
                }

                const blanks = hanTuChars.map((char, idx) => {
                    if (indicesToMiss.has(idx)) {
                        return { original: char, display: '___', input: '', isMissing: true, isCorrect: null };
                    }
                    return { original: char, display: char, input: char, isMissing: false, isCorrect: null };
                });
                setFillInBlanksWords(blanks);
                setSentenceInput('');
                setIsCorrect(null);
            };

            const handleFillInBlanksInput = (e, index) => {
                const newValue = e.target.value;
                setFillInBlanksWords(prev =>
                    prev.map((word, i) => i === index ? { ...word, input: newValue } : word)
                );
            };

            const checkFillInBlanksAnswer = async () => {
                let allCorrect = true;
                let newBlanks = [...fillInBlanksWords];

                newBlanks.forEach(word => {
                    if (word.isMissing) {
                        const isCharCorrect = normalizeHanTu(word.input) === normalizeHanTu(word.original);
                        word.isCorrect = isCharCorrect; 
                        if (!isCharCorrect) allCorrect = false;
                    }
                });
                setFillInBlanksWords(newBlanks);

                if (allCorrect) {
                    setIsCorrect(true);
                    setMessage({ text: "Chính xác!", type: "success" });
                    await speakSentence(selectedPassage.sentences[currentSentenceIndex]);
                } else {
                    setIsCorrect(false);
                    setMessage({ text: "Sai rồi. Vui lòng thử lại.", type: "error" });
                    setShaking(true);
                    setTimeout(() => setShaking(false), 500);
                }
            };

            const setupDictation = () => {
                if (!selectedPassage || !selectedPassage.sentences || selectedPassage.sentences.length === 0) return;
                const sentence = selectedPassage.sentences[currentSentenceIndex];
                setDictationCorrectAnswer(normalizeHanTu(sentence.chinese));
                setSentenceInput('');
                setIsCorrect(null);
            };

            const checkDictationAnswer = async () => {
                const submittedText = normalizeHanTu(sentenceInput);
                const correctText = dictationCorrectAnswer;

                if (submittedText === correctText) {
                    setIsCorrect(true);
                    setMessage({ text: "Chính xác!", type: "success" });
                    await speakSentence(selectedPassage.sentences[currentSentenceIndex]);
                } else {
                    setIsCorrect(false);
                    setMessage({ text: `Sai rồi! Đáp án đúng là: "${selectedPassage.sentences[currentSentenceIndex].chinese}"`, type: "error" });
                    setShaking(true);
                    setTimeout(() => setShaking(false), 500);
                }
            };

            // NEW: useEffect for keyboard controls in Review Game
            useEffect(() => {
                const handleKeyPress = (event) => {
                    // Only active when in 'review' view and not processing
                    if (view === 'review' && !isProcessing) {
                        if (event.key === 'Enter') {
                            event.preventDefault(); // Prevent default Enter key behavior (e.g., submitting form twice, new line in textarea)

                            // If an answer has been given (isCorrect is true/false or rearrangeIsAnswered is true)
                            // AND it's not a text input field (to allow Enter for typing)
                            // AND it's not the rearrange example type where Enter is for checking
                            if ((isCorrect !== null || rearrangeIsAnswered) &&
                                !(questionType === 'typePinyin' && document.activeElement === document.getElementById('pinyin-input')) &&
                                !(questionType === 'typeHanTu' && document.activeElement === document.getElementById('hantu-input')) &&
                                !(questionType === 'dictation' && document.activeElement === document.getElementById('dictation-input')) &&
                                !(questionType === 'fillInBlanks' && Array.from(document.querySelectorAll('input[id^="fill-blank-"]')).some(input => input === document.activeElement)) &&
                                !(questionType === 'rearrangeExample' && !rearrangeIsAnswered)
                                ) {
                                handleNextQuestion();
                            } else {
                                // If no answer given yet, or it's a text input field, try to submit the answer
                                switch (questionType) {
                                    case 'typePinyin':
                                        // Only submit if the input field is active or if it's not empty
                                        if (document.activeElement === document.getElementById('pinyin-input') || pinyinInput.trim() !== '') {
                                            handlePinyinSubmit(event);
                                        }
                                        break;
                                    case 'typeHanTu':
                                        if (document.activeElement === document.getElementById('hantu-input') || hanTuInput.trim() !== '') {
                                            handleHanTuSubmit(event);
                                        }
                                        break;
                                    case 'fillInBlanks':
                                        // Check if any blank input is focused
                                        const anyBlankFocused = fillInBlanksWords.some((word, idx) =>
                                            word.isMissing && document.activeElement === document.getElementById(`fill-blank-${idx}`)
                                        );
                                        if (anyBlankFocused || fillInBlanksWords.some(word => word.input.trim() !== '')) {
                                            checkFillInBlanksAnswer();
                                        }
                                        break;
                                    case 'dictation':
                                        if (document.activeElement === document.getElementById('dictation-input') || sentenceInput.trim() !== '') {
                                            checkDictationAnswer();
                                        }
                                        break;
                                    case 'rearrangeExample':
                                        if (!rearrangeIsAnswered && selectedWords.length > 0) { // Only check if words are selected for rearrange
                                            handleRearrangeCheck();
                                        }
                                        break;
                                    // For multiple-choice, Enter doesn't select an option, so we only handle next question after selection
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                };

                document.addEventListener('keydown', handleKeyPress);

                return () => {
                    document.removeEventListener('keydown', handleKeyPress);
                };
            }, [view, isProcessing, isCorrect, questionType, pinyinInput, hanTuInput, sentenceInput, fillInBlanksWords, selectedWords, rearrangeIsAnswered, handleNextQuestion, handlePinyinSubmit, handleHanTuSubmit, checkFillInBlanksAnswer, checkDictationAnswer, handleRearrangeCheck]);

            const handleNextSentence = () => {
                stopSpeaking();
                stopPlayingAllPassage();
                if (currentSentenceIndex < selectedPassage.sentences.length - 1) {
                    setCurrentSentenceIndex(prev => prev + 1);
                    setIsCorrect(null);
                    setSentenceInput('');
                    setShaking(false);
                    setMessage(null);
                    setPopupWord(null);
                } else {
                    setMessage({ text: "Bạn đã hoàn thành bài khóa này!", type: "success" });
                    stopSpeaking();
                    setView('passageList');
                }
            };

            useEffect(() => {
                if (selectedPassage) {
                    if (passageMode === 'fillInBlanks') {
                        setupFillInBlanks();
                    } else if (passageMode === 'dictation') {
                        setupDictation();
                    }

                    // Tự động phát toàn bộ bài khóa khi vào chế độ nghe hoặc đọc lần đầu
                    // hoặc khi chuyển câu/mode và chưa có chế độ phát cả bài đang chạy
                    if ((passageMode === 'reading' || passageMode === 'listening') && !isPlayingAllPassage.current) {
                        // Nếu là câu đầu tiên hoặc đang chuyển sang mode này, phát cả bài
                        if (currentSentenceIndex === 0 || view === 'passageStudy') { // view === 'passageStudy' để bắt sự kiện khi mới vào màn hình
                            playFullPassage(currentSentenceIndex); // Bắt đầu phát từ câu hiện tại
                        } else {
                            // Nếu không, chỉ phát câu hiện tại
                            speakSentence(selectedPassage.sentences[currentSentenceIndex]);
                        }
                    } else if (passageMode !== 'reading' && passageMode !== 'listening') {
                        // Nếu không phải mode nghe/đọc, đảm bảo dừng phát cả bài
                        stopPlayingAllPassage();
                    }
                }
            }, [currentSentenceIndex, passageMode, selectedPassage, passagePlaybackRate, view]);

            useEffect(() => {
                if (view !== 'passageStudy' && popupWord) {
                    setPopupWord(null);
                    if (popupRef.current) {
                        popupRef.current.style.display = 'none';
                    }
                }
                if (view !== 'passageStudy') {
                    stopSpeaking();
                    stopPlayingAllPassage();
                }
            }, [view]);


            const renderPassageForm = (isEditMode) => (
                <form onSubmit={isEditMode ? handleUpdatePassageSubmit : handleCreatePassageSubmit} className="space-y-4 relative">
                    {isProcessing && <div className="form-overlay"><LoadingSpinner /><p className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center text-lg font-semibold text-gray-700 mt-16">Đang lưu bài khóa...</p></div>}
                    <h2 className="text-3xl font-bold text-gray-800 mb-6">
                        {isEditMode ? `Chỉnh Sửa Bài Khóa: ${editingPassage?.title}` : `Thêm Bài Khóa vào Bài: ${selectedLesson?.name}`}
                    </h2>
                    <div>
                        <label htmlFor="passageTitle" className="block text-sm font-medium text-gray-700">Tiêu đề Bài Khóa:</label>
                        <input type="text" id="passageTitle" value={passageTitle} onChange={(e) => setPassageTitle(e.target.value)} required
                               className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-indigo-500 focus:border-indigo-500"
                               disabled={isProcessing} />
                    </div>

                    <h3 className="text-xl font-semibold text-gray-700 mt-6 mb-4">Các Câu trong Bài Khóa:</h3>
                    <div className="space-y-4">
                        {passageSentences.map((sentence, index) => (
                            <div key={index} className="grid grid-cols-1 md:grid-cols-2 gap-4 border p-3 rounded-md bg-gray-50 relative">
                                <div className="absolute top-2 right-2">
                                    <button type="button" onClick={() => handleRemovePassageSentence(index)}
                                            className="text-red-500 hover:text-red-700 text-lg"
                                            title="Xóa câu này"
                                            disabled={isProcessing || passageSentences.length <= 1}>
                                        <i className="fas fa-times-circle"></i>
                                    </button>
                                </div>
                                <div className="col-span-2 mb-2">
                                    <label className="block text-sm font-medium text-gray-700">Người nói (A/B/Trống):</label>
                                    <input type="text" value={sentence.speaker} onChange={(e) => handlePassageSentenceChange(index, 'speaker', e.target.value)}
                                           className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
                                           disabled={isProcessing}
                                           placeholder="Ví dụ: A, B" />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700">Câu {index + 1} (Hán tự):</label>
                                    <input type="text" value={sentence.chinese} onChange={(e) => handlePassageSentenceChange(index, 'chinese', e.target.value)}
                                           className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
                                           disabled={isProcessing} />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700">Bính âm:</label>
                                    <input type="text" value={sentence.pinyin} onChange={(e) => handlePassageSentenceChange(index, 'pinyin', e.target.value)}
                                           className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
                                           disabled={isProcessing} />
                                </div>
                                <div className="col-span-2">
                                    <label className="block text-sm font-medium text-gray-700">Nghĩa tiếng Việt:</label>
                                    <input type="text" value={sentence.vietnamese} onChange={(e) => handlePassageSentenceChange(index, 'vietnamese', e.target.value)}
                                           className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
                                           disabled={isProcessing} />
                                </div>
                                <div className="col-span-2">
                                    <label className="block text-sm font-medium text-gray-700">File âm thanh câu (MP3):</label>
                                    <input type="file" id={`passageAudio-${index}`} accept="audio/mpeg" onChange={(e) => handlePassageSentenceAudioChange(e, index)}
                                           className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
                                           disabled={isProcessing} />
                                    {(sentence.audioFileBlob || sentence.audioFileId) && (
                                        <div className="flex items-center space-x-2 mt-2 text-sm text-gray-600">
                                            <span>{sentence.audioFileBlob ? sentence.audioFileBlob.name : 'File đã chọn'}</span>
                                            <button type="button" onClick={() => handleRemovePassageSentenceAudio(index)} className="text-red-500 hover:text-red-700"
                                                    disabled={isProcessing}>
                                                <i className="fas fa-times-circle"></i>
                                            </button>
                                        </div>
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>
                    <div className="flex justify-between space-x-2">
                        <button type="button" onClick={() => handleAddPassageSentence()}
                                className={`flex-1 bg-gray-200 text-gray-800 py-2 px-4 rounded-xl hover:bg-gray-300 transition-colors duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                disabled={isProcessing}>
                            <i className="fas fa-plus mr-2"></i> Thêm Câu Mới
                        </button>
                        <button type="button" onClick={() => handleAddPassageSentence('A')}
                                className={`flex-1 bg-blue-100 text-blue-800 py-2 px-4 rounded-xl hover:bg-blue-200 transition-colors duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                disabled={isProcessing}>
                            <i className="fas fa-plus mr-2"></i> Thêm lượt thoại A
                        </button>
                        <button type="button" onClick={() => handleAddPassageSentence('B')}
                                className={`flex-1 bg-green-100 text-green-800 py-2 px-4 rounded-xl hover:bg-green-200 transition-colors duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                disabled={isProcessing}>
                            <i className="fas fa-plus mr-2"></i> Thêm lượt thoại B
                        </button>
                    </div>

                    <button type="submit"
                            className={`w-full bg-indigo-600 text-white py-3 px-4 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isProcessing}>
                        {isProcessing ? <LoadingSpinner /> : (isEditMode ? 'Lưu Chỉnh Sửa Bài Khóa' : 'Thêm Bài Khóa')}
                    </button>
                    <button type="button" onClick={() => setView('passageList')}
                            className="w-full mt-2 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md"
                            disabled={isProcessing}>
                        <i className="fas fa-arrow-left mr-2"></i> Quay Lại Danh Sách Bài Khóa
                    </button>
                </form>
            );

            const renderPassageList = () => {
                const currentLesson = lessons.find(l => l.id === selectedLesson.id);
                const passagesInLesson = currentLesson ? (currentLesson.passages || []) : [];

                return (
                    <>
                        <h2 className="text-3xl font-bold text-gray-800 mb-6 flex justify-between items-center">
                            Bài Khóa của Bài Học: <span className="text-indigo-600">{selectedLesson?.name}</span>
                            <button onClick={() => { setView('createPassage'); setPassageTitle(''); setPassageSentences([{ chinese: '', pinyin: '', vietnamese: '', audioFileBlob: null, audioFileId: null, speaker: '' }]); }}
                                    className={`bg-indigo-500 text-white text-sm py-2 px-4 rounded-full hover:bg-indigo-600 transition-colors duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                    disabled={isProcessing}>
                                <i className="fas fa-plus mr-1"></i> Thêm Bài Khóa
                            </button>
                        </h2>

                        {passagesInLesson.length === 0 ? (
                            <p className="text-gray-600 text-center py-8">Chưa có bài khóa nào trong bài học này. Hãy thêm một bài mới!</p>
                        ) : (
                            <div className="space-y-4">
                                {passagesInLesson.map(passage => (
                                    <div key={passage.id} className="bg-gray-50 p-4 rounded-xl shadow-sm border border-gray-200">
                                        <div className="flex justify-between items-start mb-2">
                                            <div>
                                                <h3 className="text-xl font-bold text-gray-900">{passage.title}</h3>
                                                <p className="text-gray-500 text-sm">Số câu: {passage.sentences.length}</p>
                                            </div>
                                            <div className="flex space-x-2">
                                                <button onClick={() => handleEditPassage(passage)}
                                                        className={`bg-blue-500 text-white text-xs p-2 rounded-full hover:bg-blue-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                        title="Chỉnh Sửa Bài Khóa"
                                                        disabled={isProcessing}>
                                                    <i className="fas fa-edit"></i>
                                                </button>
                                                <button onClick={() => startPassageStudy(passage)}
                                                        className={`bg-green-500 text-white text-xs p-2 rounded-full hover:bg-green-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                        title="Học Bài Khóa Này"
                                                        disabled={isProcessing}>
                                                    <i className="fas fa-book-reader"></i>
                                                </button>
                                                <button onClick={() => handleDeletePassage(passage.id)}
                                                        className={`bg-red-500 text-white text-xs p-2 rounded-full hover:bg-red-600 transition-colors duration-200 ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                        disabled={isProcessing}>
                                                    <i className="fas fa-trash"></i>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                        <button type="button" onClick={() => { setView('lessonList'); setSelectedLesson(null); }}
                                className={`w-full mt-8 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                disabled={isProcessing}>
                            <i className="fas fa-arrow-left mr-2"></i> Quay Lại Danh Sách Bài Học
                        </button>
                    </>
                );
            };

            const renderPassageStudy = () => {
                if (!selectedPassage || selectedPassage.sentences.length === 0) {
                    return (
                        <p className="text-gray-600 text-center py-8">
                            Bài khóa này không có nội dung. Vui lòng quay lại và thêm câu.
                        </p>
                    );
                }

                const currentSentence = selectedPassage.sentences[currentSentenceIndex];

                return (
                    <>
                        <h2 className="text-3xl font-bold text-gray-800 mb-6 text-center">
                            Bài Khóa: <span className="text-indigo-600">{selectedPassage.title}</span>
                        </h2>

                        <div className="flex flex-wrap justify-center gap-2 mb-6 p-3 bg-gray-100 rounded-lg shadow-sm">
                            <button onClick={() => { stopSpeaking(); stopPlayingAllPassage(); setPassageMode('reading'); setCurrentSentenceIndex(0); setSentenceInput(''); setIsCorrect(null); }}
                                    className={`px-4 py-2 rounded-lg text-sm font-semibold ${passageMode === 'reading' ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'}`}
                                    disabled={isProcessing}>
                                <i className="fas fa-book-open mr-1"></i> Chế độ Đọc
                            </button>
                            <button onClick={() => { stopSpeaking(); stopPlayingAllPassage(); setPassageMode('listening'); setCurrentSentenceIndex(0); setSentenceInput(''); setIsCorrect(null); }}
                                    className={`px-4 py-2 rounded-lg text-sm font-semibold ${passageMode === 'listening' ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'}`}
                                    disabled={isProcessing}>
                                <i className="fas fa-headphones mr-1"></i> Chế độ Nghe
                            </button>
                            <button onClick={() => { stopSpeaking(); stopPlayingAllPassage(); setPassageMode('fillInBlanks'); setCurrentSentenceIndex(0); setSentenceInput(''); setIsCorrect(null); }}
                                    className={`px-4 py-2 rounded-lg text-sm font-semibold ${passageMode === 'fillInBlanks' ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'}`}
                                    disabled={isProcessing}>
                                <i className="fas fa-pencil-alt mr-1"></i> Điền từ
                            </button>
                            <button onClick={() => { stopSpeaking(); stopPlayingAllPassage(); setPassageMode('dictation'); setCurrentSentenceIndex(0); setSentenceInput(''); setIsCorrect(null); }}
                                    className={`px-4 py-2 rounded-lg text-sm font-semibold ${passageMode === 'dictation' ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'}`}
                                    disabled={isProcessing}>
                                <i className="fas fa-keyboard mr-1"></i> Ghi chép
                            </button>
                            
                            {(passageMode === 'reading' || passageMode === 'listening') && (
                                <button onClick={() => isPlayingAllPassage.current ? stopPlayingAllPassage() : playFullPassage()}
                                        className={`px-4 py-2 rounded-lg text-sm font-semibold ${isPlayingAllPassage.current ? 'bg-red-500 text-white' : 'bg-purple-500 text-white hover:bg-purple-600'}`}
                                        disabled={isProcessing}>
                                    <i className={`fas ${isPlayingAllPassage.current ? 'fa-stop' : 'fa-play'} mr-1`}></i> {isPlayingAllPassage.current ? 'Dừng phát cả bài' : 'Phát cả bài'}
                                </button>
                            )}

                            {passageMode === 'reading' && (
                                <>
                                    <button onClick={() => setShowPassagePinyin(prev => !prev)}
                                            className={`px-4 py-2 rounded-lg text-sm font-semibold ${showPassagePinyin ? 'bg-teal-600 text-white' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'}`}
                                            disabled={isProcessing}>
                                        <i className="fas fa-font mr-1"></i> {showPassagePinyin ? 'Ẩn Bính âm' : 'Hiện Bính âm'}
                                    </button>
                                    <button onClick={() => setShowPassageMeaning(prev => !prev)}
                                            className={`px-4 py-2 rounded-lg text-sm font-semibold ${showPassageMeaning ? 'bg-teal-600 text-white' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'}`}
                                            disabled={isProcessing}>
                                        <i className="fas fa-language mr-1"></i> {showPassageMeaning ? 'Ẩn Nghĩa' : 'Hiện Nghĩa'}
                                    </button>
                                </>
                            )}
                        </div>

                        <div className="flex items-center justify-center gap-2 mb-4">
                            <label htmlFor="playbackRate" className="text-gray-700 text-sm font-semibold">Tốc độ đọc:</label>
                            <input
                                type="range"
                                id="playbackRate"
                                min="0.5"
                                max="2.0"
                                step="0.1"
                                value={passagePlaybackRate}
                                onChange={(e) => {
                                    const newRate = parseFloat(e.target.value);
                                    setPassagePlaybackRate(newRate);
                                    if (currentUtteranceInstance) {
                                        currentUtteranceInstance.rate = newRate;
                                    }
                                }}
                                className="w-32 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg"
                                disabled={isProcessing}
                            />
                            <span className="text-gray-700 text-sm">{passagePlaybackRate.toFixed(1)}x</span>
                        </div>

                        <div className="bg-white p-6 rounded-xl shadow-lg border border-gray-200 relative text-center">
                            {passageMode !== 'reading' && passageMode !== 'listening' && (
                                <div className="flex items-center justify-between mb-4">
                                    <button onClick={() => { stopSpeaking(); setCurrentSentenceIndex(prev => Math.max(0, prev - 1)); }}
                                            className="text-gray-600 hover:text-gray-800 text-2xl"
                                            disabled={currentSentenceIndex === 0 || isProcessing}>
                                        <i className="fas fa-arrow-alt-circle-left"></i>
                                    </button>
                                    <span className="text-gray-700 font-semibold text-lg">{currentSentenceIndex + 1} / {selectedPassage.sentences.length}</span>
                                    <button onClick={() => { stopSpeaking(); handleNextSentence(); }}
                                            className="text-gray-600 hover:text-gray-800 text-2xl"
                                            disabled={currentSentenceIndex === selectedPassage.sentences.length -1 && isCorrect === null || isProcessing}>
                                        <i className="fas fa-arrow-alt-circle-right"></i>
                                    </button>
                                </div>
                            )}

                            {passageMode !== 'reading' && passageMode !== 'listening' && (
                                <div className="flex items-center justify-center mb-4">
                                    <button onClick={() => speakSentence(currentSentence)}
                                            className="text-indigo-600 hover:text-indigo-800 text-4xl focus:outline-none"
                                            disabled={isProcessing}>
                                        <i className="fas fa-volume-up"></i>
                                    </button>
                                </div>
                            )}

                            {passageMode === 'reading' && (
                                <div className="text-gray-800 text-2xl leading-relaxed text-left max-h-[60vh] overflow-y-auto" onMouseLeave={() => setPopupWord(null)}>
                                    {selectedPassage.sentences.map((sentence, sIdx) => (
                                        <div key={sIdx} className={`my-4 p-2 rounded-lg flex items-start 
                                            ${sentence.speaker === 'A' ? 'pl-8 bg-blue-50' : 
                                            sentence.speaker === 'B' ? 'pl-8 bg-green-50' : ''}`}>
                                            <button onClick={() => speakSentence(sentence)}
                                                    className="text-indigo-600 hover:text-indigo-800 text-xl focus:outline-none mr-2 flex-shrink-0"
                                                    disabled={isProcessing}>
                                                <i className="fas fa-volume-up"></i>
                                            </button>
                                            <div className="flex-grow">
                                                {sentence.speaker && <span className="font-bold mr-2 text-gray-700">{sentence.speaker}：</span>}
                                                <span className="passage-sentence-text">
                                                    {sentence.chinese.split('').map((char, index) => (
                                                        <span key={`${sIdx}-${index}`}
                                                              onClick={(e) => handleWordClickInPassage(e, sentence.chinese)}
                                                              className="hanzi-char-span inline-block cursor-pointer hover:bg-blue-100 rounded-sm px-1 py-0.5 transition-colors duration-100">
                                                            {char}
                                                        </span>
                                                    ))}
                                                </span>
                                                {showPassagePinyin && <p className="text-indigo-600 text-lg mt-1">{sentence.pinyin}</p>}
                                                {showPassageMeaning && <p className="text-gray-700 text-lg mt-1">{sentence.vietnamese}</p>}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}

                            {passageMode === 'listening' && (
                                <div className="text-gray-800 text-2xl leading-relaxed text-center min-h-[100px] flex flex-col items-center justify-center">
                                    <p className="text-gray-500 text-lg">Nghe và cố gắng hiểu nghĩa</p>
                                    <p className="text-gray-500 text-sm mt-2">(Chế độ này không hiển thị chữ, chỉ phát âm thanh.)</p>
                                </div>
                            )}

                            {passageMode === 'fillInBlanks' && (
                                <div className="text-gray-800 text-2xl leading-relaxed text-center">
                                    <div className={`mb-4 ${shaking ? 'animate-shake' : ''}`}>
                                        {fillInBlanksWords.map((wordObj, index) => (
                                            wordObj.isMissing ? (
                                                <input
                                                    key={index}
                                                    id={`fill-blank-${index}`}
                                                    type="text"
                                                    value={wordObj.input}
                                                    onChange={(e) => handleFillInBlanksInput(e, index)}
                                                    className={`w-20 text-center border-b-2 bg-gray-50 mx-1 focus:outline-none text-xl
                                                        ${isCorrect === null ? 'border-indigo-400' :
                                                          wordObj.isCorrect ? 'border-green-500 text-green-700' : 'border-red-500 text-red-700'
                                                        }`}
                                                    disabled={isCorrect !== null || isProcessing}
                                                />
                                            ) : (
                                                <span key={index} className="mx-1">{wordObj.original}</span>
                                            )
                                        ))}
                                    </div>
                                    {isCorrect === null && (
                                        <button onClick={checkFillInBlanksAnswer}
                                                className={`mt-4 bg-indigo-600 text-white py-2 px-4 rounded-xl hover:bg-indigo-700 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                disabled={isProcessing}>
                                            Kiểm tra
                                        </button>
                                    )}
                                    {isCorrect !== null && (
                                        <p className={`mt-2 font-bold ${isCorrect ? 'text-green-600' : 'text-red-600'}`}>
                                            {isCorrect ? 'Chính xác!' : `Sai! Đáp án đúng: ${currentSentence.chinese}`}
                                        </p>
                                    )}
                                </div>
                            )}

                            {passageMode === 'dictation' && (
                                <div className="text-gray-800 text-2xl leading-relaxed text-center">
                                    <input
                                        type="text"
                                        id="dictation-input"
                                        value={sentenceInput}
                                        onChange={(e) => setSentenceInput(e.target.value)}
                                        placeholder="Gõ toàn bộ câu ở đây..."
                                        className={`w-full border-b-2 bg-gray-50 mx-auto p-2 text-xl text-center focus:outline-none
                                            ${isCorrect === null ? 'border-indigo-400' :
                                              isCorrect ? 'border-green-500 text-green-700' : 'border-red-500 text-red-700'
                                            } ${shaking ? 'animate-shake' : ''}`}
                                        disabled={isCorrect !== null || isProcessing}
                                    />
                                    {isCorrect === null && (
                                        <button onClick={checkDictationAnswer}
                                                className={`mt-4 bg-indigo-600 text-white py-2 px-4 rounded-xl hover:bg-indigo-700 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                disabled={isProcessing}>
                                            Kiểm tra
                                        </button>
                                    )}
                                    {isCorrect !== null && (
                                        <p className={`mt-2 font-bold ${isCorrect ? 'text-green-600' : 'text-red-600'}`}>
                                            {isCorrect ? 'Chính xác!' : `Sai! Đáp án đúng: ${currentSentence.chinese}`}
                                        </p>
                                    )}
                                </div>
                            )}
                        </div>

                        {popupWord && (
                            <div ref={popupRef} className="absolute bg-white p-4 rounded-lg shadow-xl border border-gray-300 z-50 text-left min-w-[250px] animate-fade-in" style={{ display: 'none' }}>
                                <h4 className="text-xl font-bold text-gray-900 mb-1">{popupWord.hanTu}
                                    {popupWord.hanTu && (
                                        <button onClick={(e) => { e.stopPropagation(); handlePlayDetailAudio(popupWord.audioFile, popupWord.hanTu); }}
                                                className="text-indigo-600 text-base ml-2 hover:text-indigo-800 focus:outline-none"
                                                disabled={isProcessing}>
                                            <i className="fas fa-volume-up"></i>
                                        </button>
                                    )}
                                </h4>
                                <p className="text-indigo-600 text-base">{popupWord.pinyin}</p>
                                <p className="text-gray-700 text-sm mt-1">
                                    Nghĩa: {popupWord.hanVietMeaning && <span className="text-gray-500">[{popupWord.hanVietMeaning}] </span>}
                                    <span className="font-medium">{popupWord.meaning}</span>
                                </p>
                                {popupWord.notes && <p className="text-gray-600 text-xs mt-1">Ghi chú: {popupWord.notes}</p>}
                                {popupWord.examples && popupWord.examples.filter(ex => ex.chinese).length > 0 && (
                                    <div className="mt-2 text-xs text-gray-800">
                                        <p className="font-semibold mb-1">Ví dụ:</p>
                                        <ul className="list-disc list-inside space-y-0.5">
                                            {popupWord.examples.filter(ex => ex.chinese).map((ex, idx) => (
                                                <li key={idx} className="flex items-center">
                                                    {ex.chinese && (
                                                        <button onClick={(e) => { e.stopPropagation(); handlePlayDetailAudio(ex.audioFile, ex.chinese); }}
                                                                className="text-indigo-600 text-xs mr-1 focus:outline-none hover:text-indigo-800"
                                                                disabled={isProcessing}>
                                                            <i className="fas fa-volume-up"></i>
                                                        </button>
                                                    )}
                                                    <span>{ex.chinese} <span className="text-gray-500">- {ex.vietnamese}</span></span>
                                                </li>
                                            ))}
                                        </ul>
                                    </div>
                                )}
                                <button onClick={() => setPopupWord(null)} className="absolute top-2 right-2 text-gray-500 hover:text-gray-700 text-sm">
                                    <i className="fas fa-times"></i>
                                </button>
                            </div>
                        )}


                        <button type="button" onClick={() => { stopSpeaking(); stopPlayingAllPassage(); setView('passageList'); setSelectedPassage(null); }}
                                className={`w-full mt-8 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                disabled={isProcessing}>
                            <i className="fas fa-arrow-left mr-2"></i> Quay Lại Danh Sách Bài Khóa
                        </button>
                    </>
                );
            };

            const ReviewGame = () => (
                <div className="container mx-auto grid gap-4">
                    <h2 className="text-3xl font-bold text-gray-800 mb-6 flex justify-between items-center">
                        Ôn Tập ({currentQuestionNumber + 1} / {totalQuestions})
                        {reviewMode === 'singleLesson' && selectedLesson && (
                            <span className="text-indigo-600"> {selectedLesson.name}</span>
                        )}
                        <label className="flex items-center space-x-2 text-base font-normal">
                            <input
                                type="checkbox"
                                checked={showPinyin}
                                onChange={(e) => setShowPinyin(e.target.checked)}
                                className="form-checkbox h-5 w-5 text-indigo-600 rounded"
                                disabled={isProcessing}
                            />
                            <span>Hiện Bính Âm</span>
                        </label>
                    </h2>
                    {!question ? (
                        <p className="text-gray-600 text-center py-8">
                            Không có từ vựng nào để ôn tập. Vui lòng tạo từ vựng trước.
                        </p>
                    ) : (
                        <div className="space-y-6">
                            <div className="bg-blue-100 p-6 rounded-xl shadow-md text-center">
                                <p className="text-gray-700 text-lg mb-2">
                                    {question.type === 'translateWord' && 'Câu hỏi (Dịch từ Hán tự):'}
                                    {question.type === 'typePinyin' && 'Câu hỏi (Gõ Bính âm cho Hán tự):'}
                                    {question.type === 'translateMeaning' && 'Câu hỏi (Dịch từ Tiếng Việt):'}
                                    {question.type === 'translateVietToHanTuMC' && 'Câu hỏi (Dịch từ Tiếng Việt - Chọn Hán tự):'}
                                    {question.type === 'translateExample' && 'Câu hỏi (Dịch câu ví dụ):'}
                                    {question.type === 'typeHanTu' && 'Câu hỏi (Gõ Hán tự cho Tiếng Việt):'}
                                    {question.type === 'rearrangeExample' && 'Câu hỏi (Sắp xếp từ thành câu):'}
                                </p>
                                <p className={`text-5xl font-extrabold text-blue-700 ${shaking ? 'animate-shake' : ''}`}>
                                    {question.text}
                                </p>
                                {/* Pinyin display logic is slightly modified to be more consistent based on type */}
                                {/* Only show pinyin for typing questions if the answer is revealed, or if global showPinyin is true for others */}
                                {((question.type === 'translateWord' || question.type === 'translateMeaning' || question.type === 'translateVietToHanTuMC') && showPinyin && question.vocab.pinyin) && (
                                    <p className="text-indigo-600 text-2xl mt-2">{question.vocab.pinyin}</p>
                                )}

                                {/* Audio button for main vocab or example, always visible if there's text to speak */}
                                {question.vocab.hanTu && ( /* Check if hanTu exists to ensure there's text to speak */
                                    (question.type !== 'translateExample' && question.type !== 'rearrangeExample') && ( /* Only show if not example-based question */
                                        <button onClick={() => handlePlayDetailAudio(question.vocab.audioFile, question.vocab.hanTu)} // Pass audioFile ID and hanTu text
                                                className="text-indigo-600 text-xl mt-2 focus:outline-none hover:text-indigo-800"
                                                disabled={isProcessing}>
                                            <i className="fas fa-volume-up"></i>
                                        </button>
                                    )
                                )}
                                {(question.type === 'translateExample' || question.type === 'rearrangeExample') && question.text && ( /* Check if example text exists */
                                    <button onClick={() => handlePlayDetailAudio(question.exampleAudioId, question.text)} // Pass exampleAudioId and example text
                                            className="text-indigo-600 text-xl mt-2 focus:outline-none hover:text-indigo-800"
                                            disabled={isProcessing}>
                                        <i className="fas fa-volume-up"></i>
                                    </button>
                                )}
                            </div>

                            {/* Conditional rendering for question types */}
                            {questionType === 'typePinyin' ? (
                                <form onSubmit={handlePinyinSubmit} className="space-y-4">
                                    <input
                                        type="text"
                                        id="pinyin-input" // Added ID
                                        value={pinyinInput}
                                        onChange={(e) => setPinyinInput(e.target.value)}
                                        placeholder="Gõ bính âm vào đây..."
                                        className="w-full border border-gray-300 rounded-md shadow-sm p-3 text-lg focus:ring-indigo-500 focus:border-indigo-500 text-center"
                                        disabled={isCorrect !== null || isProcessing}
                                    />
                                    <button type="submit"
                                            className={`w-full bg-indigo-600 text-white py-3 px-4 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isCorrect !== null || isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                            disabled={isProcessing}>
                                        {isProcessing ? <LoadingSpinner /> : 'Kiểm Tra'}
                                    </button>
                                </form>
                            ) : questionType === 'typeHanTu' ? (
                                <form onSubmit={handleHanTuSubmit} className="space-y-4">
                                    <input
                                        type="text"
                                        id="hantu-input" // Added ID
                                        value={hanTuInput}
                                        onChange={(e) => setHanTuInput(e.target.value)}
                                        placeholder="Gõ Hán tự vào đây..."
                                        className="w-full border border-gray-300 rounded-md shadow-sm p-3 text-lg focus:ring-indigo-500 focus:border-indigo-500 text-center"
                                        disabled={isCorrect !== null || isProcessing}
                                    />
                                    <button type="submit"
                                            className={`w-full bg-indigo-600 text-white py-3 px-4 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                            disabled={isProcessing}>
                                        {isProcessing ? <LoadingSpinner /> : 'Kiểm Tra'}
                                    </button>
                                </form>
                            ) : questionType === 'rearrangeExample' ? (
                                <div className="space-y-4">
                                    <div className="flex flex-wrap justify-center items-center gap-2 p-4 bg-gray-100 border border-gray-300 rounded-md min-h-[60px]">
                                        {selectedWords.length === 0 && !rearrangeIsAnswered && <span className="text-gray-500">Sắp xếp câu tại đây...</span>}
                                        {selectedWords.map((word, idx) => (
                                            <span key={idx} className="bg-blue-200 text-blue-800 px-3 py-1 rounded-md text-lg font-medium">
                                                {word}
                                            </span>
                                        ))}
                                    </div>
                                    <div className="flex flex-wrap justify-center gap-2 mt-4">
                                        {scrambledWords.map((item, idx) => (
                                            <button
                                                key={item.id} // Use unique ID from item for key
                                                onClick={() => handleWordClick(item, idx)}
                                                className={`px-4 py-2 rounded-lg font-semibold transition-colors duration-200
                                                    ${item.isUsed || rearrangeIsAnswered ? 'bg-gray-300 text-gray-600 opacity-50 cursor-not-allowed' : 'bg-white text-gray-800 hover:bg-gray-100'}
                                                    shadow-sm`}
                                                disabled={item.isUsed || rearrangeIsAnswered || isProcessing}
                                            >
                                                {item.word}
                                            </button>
                                        ))}
                                    </div>
                                    {!rearrangeIsAnswered && (
                                        <div className="flex justify-center space-x-4 mt-6">
                                            <button onClick={handleRearrangeCheck}
                                                    className="bg-green-600 text-white py-2 px-4 rounded-lg hover:bg-green-700 shadow-md"
                                                    disabled={selectedWords.length === 0 || isProcessing}>
                                                Kiểm tra
                                            </button>
                                            <button onClick={handleRearrangeReset}
                                                    className="bg-yellow-500 text-white py-2 px-4 rounded-lg hover:bg-yellow-600 shadow-md"
                                                    disabled={isProcessing}>
                                                Làm lại
                                            </button>
                                            <button onClick={handleRearrangeGiveUp}
                                                    className="bg-red-500 text-white py-2 px-4 rounded-lg hover:bg-red-600 shadow-md"
                                                    disabled={isProcessing}>
                                                Bỏ cuộc
                                            </button>
                                        </div>
                                    )}
                                </div>
                            ) : (
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    {options.map((option, index) => (
                                        <button
                                            key={index}
                                            onClick={() => handleOptionClick(index)}
                                            className={`w-full p-4 rounded-xl text-lg font-semibold transition-all duration-300 shadow-md
                                                ${selectedOption === null ? 'bg-gray-200 hover:bg-gray-300 text-gray-800' :
                                                index === correctAnswerIndex && selectedOption !== null ? 'bg-green-500 text-white' :
                                                index === selectedOption && selectedOption !== null ? 'bg-red-500 text-white' :
                                                'bg-gray-200 text-gray-800 opacity-70 cursor-not-allowed'
                                                }`}
                                            disabled={selectedOption !== null || isProcessing}>
                                            {option}
                                        </button>
                                    ))}
                                </div>
                            )}
                            
                            {/* Next Question / Finish Button - Moved Up */}
                            {(isCorrect !== null || rearrangeIsAnswered) && ( /* Show next question button only after answer */
                                <div className="flex justify-end mt-4"> {/* Added justify-end for right align */}
                                    <button
                                        onClick={handleNextQuestion}
                                        className={`bg-indigo-600 text-white py-3 px-6 rounded-xl hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                        disabled={isProcessing}>
                                        {isProcessing ? <LoadingSpinner /> : (currentQuestionNumber < totalQuestions -1 ? 'Câu Tiếp Theo' : 'Hoàn Thành')} <i className="fas fa-arrow-right ml-2"></i>
                                    </button>
                                </div>
                            )}

                            {(isCorrect !== null || rearrangeIsAnswered) && (
                                <div className="animate-fade-in mt-4">
                                    <div className={`p-4 rounded-lg shadow-md text-center mb-4 ${
                                        isCorrect ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                                    }`}>
                                        <p className="text-lg font-bold">
                                            {isCorrect ? 'Chính xác!' : 'Sai rồi!'}
                                        </p>
                                        {!isCorrect && question.type === 'typePinyin' && (
                                            <p className="text-sm mt-1">Đáp án đúng là: <span className="font-semibold">{question.displayPinyin}</span></p>
                                        )}
                                        {!isCorrect && question.type === 'typeHanTu' && (
                                            <p className="text-sm mt-1">Đáp án đúng là: <span className="font-semibold">{question.displayHanTu}</span></p>
                                        )}
                                        {!isCorrect && (question.type === 'translateWord' || question.type === 'translateMeaning' || question.type === 'translateVietToHanTuMC' || question.type === 'translateExample') && (
                                            <p className="text-sm mt-1">Đáp án đúng là: <span className="font-semibold">{options[correctAnswerIndex]}</span></p>
                                        )}
                                        {!isCorrect && question.type === 'rearrangeExample' && (
                                            <p className="text-sm mt-1">Đáp án đúng là: <span className="font-semibold">{question.correctSequence.join('')}</span></p>
                                        )}
                                    </div>

                                    {/* Detailed Vocabulary Info Card */}
                                    <div className="bg-white p-6 rounded-xl shadow-lg border border-gray-200 text-left">
                                        <div className="flex items-center space-x-3 mb-2">
                                            <h3 className="text-3xl font-bold text-gray-900">{question.vocab.hanTu}</h3>
                                            {question.vocab.hanTu && (
                                                <button onClick={() => handlePlayDetailAudio(question.vocab.audioFile, question.vocab.hanTu)}
                                                        className="text-indigo-600 text-xl focus:outline-none hover:text-indigo-800"
                                                        disabled={isProcessing}>
                                                    <i className="fas fa-volume-up"></i>
                                                </button>
                                            )}
                                        </div>
                                        <p className="text-indigo-600 text-xl mb-2">
                                            {showPinyin ? question.vocab.pinyin : '---'}
                                        </p>
                                        <p className="text-gray-700 text-lg">
                                            Nghĩa: {question.vocab.hanVietMeaning && <span className="text-gray-500">[{question.vocab.hanVietMeaning}] </span>}
                                            <span className="font-medium">{question.vocab.meaning}</span>
                                        </p>
                                        {question.vocab.notes && <p className="text-gray-600 text-base mt-2">Ghi chú: {question.vocab.notes}</p>}
                                        
                                        {question.vocab.examples && question.vocab.examples.length > 0 && (
                                            <div className="mt-4 text-base text-gray-800">
                                                <p className="font-semibold mb-2">Ví dụ:</p>
                                                <ul className="list-none space-y-2">
                                                    {question.vocab.examples.map((ex, idx) => ex.chinese && ex.vietnamese && (
                                                        <li key={idx} className="flex items-start">
                                                            {ex.chinese && (
                                                                <button onClick={() => handlePlayDetailAudio(ex.audioFile, ex.chinese)}
                                                                        className="text-indigo-600 text-sm mr-2 focus:outline-none hover:text-indigo-800"
                                                                        disabled={isProcessing}>
                                                                    <i className="fas fa-volume-up"></i>
                                                                </button>
                                                            )}
                                                            <span>{ex.chinese} <span className="text-gray-500">- {ex.vietnamese}</span></span>
                                                        </li>
                                                    ))}
                                                </ul>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                            <button onClick={() => { setView('lessonList'); setPinyinInput(''); setHanTuInput(''); setScrambledWords([]); setSelectedWords([]); setRearrangeIsAnswered(false); /* clear inputs when leaving review */ }}
                                    className={`w-full mt-8 bg-gray-300 text-gray-800 py-3 px-4 rounded-xl hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 shadow-md ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                                    disabled={isProcessing}>
                                <i className="fas fa-arrow-left mr-2"></i> Quay Lại Danh Sách Bài Học
                            </button>
                        </div>
                    )}
                </div>
            );

            const NavigationMenu = () => (
                <nav className="grid grid-cols-3 gap-4 mb-6">
                    <button onClick={() => setView('lessonList')} className="flex items-center justify-center bg-primary text-white py-2 px-4 rounded-lg shadow hover:bg-primary-700">
                        Danh Sách
                    </button>
                    <button onClick={() => setView('createLesson')} className="flex items-center justify-center bg-primary text-white py-2 px-4 rounded-lg shadow hover:bg-primary-700">
                        Tạo Bài Học
                    </button>
                    <button onClick={() => setView('review')} className="flex items-center justify-center bg-primary text-white py-2 px-4 rounded-lg shadow hover:bg-primary-700">
                        Ôn Tập
                    </button>
                </nav>
            );

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-100 to-slate-300 dark:from-gray-900 dark:to-gray-800 flex items-center justify-center px-4 sm:px-6 py-4">
                    {loading && <FullPageLoadingOverlay message="Đang tải dữ liệu từ bộ nhớ cục bộ..." />}
                    {/* Main Content Container - Increased max-w-4xl for larger UI (was max-w-2xl) */}
                    {/* Dòng gây lỗi đã bị loại bỏ khỏi đây */}
                    <div className="bg-white dark:bg-gray-900 bg-opacity-90 dark:bg-opacity-90 backdrop-blur-md py-8 px-4 sm:px-6 rounded-3xl shadow-2xl w-full max-w-screen-lg mx-auto text-left transform transition-all duration-300">
                        {renderMessageBox()}
                        <NavigationMenu />
                        {view === 'lessonList' && <LessonList />}
                        {view === 'createLesson' && <CreateLessonForm />}
                        {view === 'editLesson' && renderEditLessonForm()}
                        {view === 'createCourse' && renderCreateCourseForm()}
                        {view === 'editCourse' && renderEditCourseForm()}
                        {view === 'vocabularyList' && renderVocabularyList()}
                        {view === 'createVocabulary' && renderCreateVocabularyForm()}
                        {view === 'editVocabulary' && renderEditVocabularyForm()}
                        {view === 'passageList' && renderPassageList()}
                        {view === 'createPassage' && renderPassageForm(false)}
                        {view === 'editPassage' && renderPassageForm(true)}
                        {view === 'review' && <ReviewGame />}
                        {view === 'passageStudy' && renderPassageStudy()}
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>